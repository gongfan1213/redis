# Netty反应器（EventLoop）核心原理总结

## 一、经典反应器模式回顾
经典反应器（Reactor）模式分为三步：
1. **注册**：通道（Channel）注册到选择器（Selector）。
2. **轮询**：反应器从选择器中轮询IO事件。
3. **分发**：反应器将IO事件分发到对应的处理器（Handler）。


## 二、Netty反应器的核心组件
Netty的反应器模式以**EventLoop**为核心，对应经典反应器角色，采用多线程设计：
- **Boss线程**：负责监听连接事件（可配置多个）。
- **Worker线程**：由多个`EventLoop`组成`EventLoopGroup`，负责处理IO传输事件。


## 三、EventLoop的核心关系
1. **EventLoop与Selector**  
   - 每个`EventLoop`包含一个原生`Selector`实例和一个专属线程。  
   - 线程负责执行`Selector`的事件轮询、任务处理和异步操作。

2. **EventLoop与Channel**  
   - 一对多关系：一个`EventLoop`可关联多个Netty`Channel`。  
   - Netty`Channel`封装了JDK原生NIO`Channel`（如`SocketChannel`），通过`AbstractNioChannel`的`selectableChannel`成员持有原生通道。


## 四、反应器模式三步实现（Netty版）

### 1. 注册：Channel注册到Selector
- **流程**：  
  通过引导类（Bootstrap）初始化，最终调用`Channel`的`doRegister`方法，将原生通道注册到`EventLoop`的`Selector`上。  
  ```java
  // 核心注册代码（简化）
  selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
  ```
  - 第三个参数`this`（当前`Channel`实例）作为附件绑定到`SelectionKey`，供后续事件处理使用。

- **关键**：注册工作必须由`EventLoop`的专属线程执行，确保线程安全。


### 2. 轮询：EventLoop的事件查询
- **线程启动时机**：  
  注册前启动`EventLoop`的专属线程，通过线程工厂创建，执行`EventLoop`的`run`方法（核心循环）。

- **轮询逻辑**：  
  `run`方法是一个死循环，主要执行：  
  - **事件查询**：通过`Selector`轮询IO事件（支持阻塞/非阻塞策略）。  
  - **任务处理**：执行任务队列（`taskQueue`）中的异步任务（如注册操作、用户自定义任务）。  
  ```java
  // run方法核心逻辑（简化）
  while (!confirmShutdown()) {
      processSelectedKeys(); // 处理IO事件
      runAllTasks(); // 处理任务队列
  }
  ```


### 3. 分发：IO事件的处理与传递
- **事件处理**：  
  轮询到IO事件后，`processSelectedKeys`方法迭代处理`SelectionKey`，根据事件类型（如可读、可写）执行对应操作：  
  - 例如，可读事件触发`doReadBytes`方法，从原生通道读取数据到`ByteBuf`。

- **数据分发**：  
  读取的数据通过`ChannelPipeline`（通道流水线）传递给绑定的`ChannelHandler`（业务处理器），完成业务逻辑处理。


## 五、EventLoop的核心特性
1. **单线程串行执行**  
   - 一个`EventLoop`对应一个线程，所有IO事件和任务串行处理，避免线程安全问题，实现无锁化设计，提升性能。

2. **任务队列**  
   - 支持异步任务提交（如`execute`方法），任务存储在`taskQueue`中，由`runAllTasks`方法串行执行。

3. **高效性**  
   - 结合NIO非阻塞特性和任务串行处理，减少线程切换开销，适合高并发场景。


## 六、总结
Netty的`EventLoop`是反应器模式的高效实现，通过**注册-轮询-分发**三步流程，结合单线程串行执行和任务队列机制，实现了高性能的IO处理。其核心优势在于：
- 封装JDK NIO组件，简化复杂操作。
- 多线程分工（Boss/Worker）提升并发处理能力。
- 无锁化设计减少线程安全问题，优化性能。

理解`EventLoop`的工作原理是掌握Netty高并发核心的关键，后续可深入学习任务队列调度和`ChannelPipeline`的流水线机制。

# Netty核心：NioEventLoop（反应器）核心原理
一手微4767893  
送课+微4767893  

<img width="626" height="396" alt="image" src="https://github.com/user-attachments/assets/18964f4d-f1de-4814-b147-9d5ee3975fc8" />

<img width="623" height="409" alt="image" src="https://github.com/user-attachments/assets/3af077e4-2d22-45b5-bb3b-c15df5636daf" />



## Netty中的Reactor模式示意图
- **结构**：包含`bossLoopGroup`和`workerLoopGroup`，其中`bossLoopGroup`的`NioEventLoop`（Reactor）负责处理`accept`事件，`workerLoopGroup`的`NioEventLoop`（Reactor）负责处理`read`、`decode`、`write`等IO事件，并通过`handler`分发处理。  
- 每个`NioEventLoop`可关联多个`Channel`，实现多线程处理IO任务。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/fd47270f-d47e-48ea-b71d-070986bc13bb" />


## NioEventLoop的两大要员
`NioEventLoop`绑定两个核心成员：  

1. **Thread**：定义在父类`SingleThreadEventExecutor`中，用于轮询NIO `Selector`、处理IO事件及其他非IO任务。  

2. **Java NIO Selector**：用于监听注册在其上的`Channel`的IO事件。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/b92cf43e-ff7f-4619-84dd-dc7423115482" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/2c0dd6b5-1713-4b8a-99d3-ce17ad9788aa" />

## EventLoop和Netty Channel的关系
- 一对多关系：一个`EventLoop`可注册多个不同的Netty `Channel`。  

## 通道注册核心代码（AbstractNioChannel.doRegister）

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/7e7a5b9e-4756-4fe3-b3a3-e1596483dcee" />

```java
@Override
protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            selectionKey = javaChannel().register(eventLoop().selector, 0, this);
            return;
        } catch (CancelledKeyException e) {
            if (!selected) {
                eventLoop().selectNow();
                selected = true;
            } else {
                throw e;
            }
        }
    }
}
```
- **关键**：第三个参数`this`为`NioSocketChannel`实例，作为附件绑定到`SelectionKey`，供事件就绪后使用，等价于`selectionKey.attach(object)`。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/ace892ff-17d1-4970-b804-731d520b4d6e" />


<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/13c7affd-36c3-45bd-babc-6863d20c6778" />

## 反应器线程的启动
1. **线程存储**：`NioEventLoop`的父类`SingleThreadEventExecutor`中通过`Thread thread`属性存储本地Java线程。  

2. **启动入口**：在`AbstractChannel.AbstractUnsafe.register`中，通过`eventLoop.execute()`触发线程启动：  
   ```java
   if (eventLoop.inEventLoop()) {
       register0(promise);
   } else {
       eventLoop.execute(new Runnable() {
           @Override
           public void run() {
               register0(promise);
           }
       });
   }
   ```
3. **启动流程**：  
   - `execute()`方法将任务加入队列，若线程未启动则调用`startThread()`。  
   - `doStartThread()`中通过线程工厂创建线程，绑定到`eventLoop`并执行`run()`方法（事件轮询与任务处理的核心逻辑）。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/50b1df2c-8c49-4af1-af9d-bfc950e5fdc4" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/74467828-a674-4fca-a0ad-67457d86d5b9" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/7a1b3b5c-3208-457d-aef7-d9b2bc7963de" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/04be2d45-2821-441b-9f65-29c8df6ff79a" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/11e7b911-30a1-49b0-8ac6-7e9b8262e51a" />

## 线程工厂与线程数
- **线程工厂**：由`MultithreadEventExecutorGroup`的`ThreadPerTaskExecutor`实现，每执行一个任务创建一个新线程。  
- **线程数**：`bossLoopGroup`和`workerLoopGroup`的线程数通过构造器参数指定，默认`workerLoopGroup`线程数为CPU核数的2倍，例如：  
  ```java
  bg = new NioEventLoopGroup(1); // boss线程组，1个线程
  wg = new NioEventLoopGroup(); // worker线程组，默认CPU核数×2
  ```

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/547b63eb-ddd8-4eae-af5c-eeb6789c7467" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/e038ba71-5729-47d6-8bf5-2f3b40cae736" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/83bdcb1b-4850-4e06-854b-8600550e0fb6" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/f82d93a5-042c-450c-b3aa-feaf6acdc487" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/ce71752e-ff77-449a-bb5c-642ffded1ddb" />

## NioEventLoop的run方法
- **核心功能**：循环处理IO任务和非IO任务：  
  - **IO任务**：通过`processSelectedKeys`处理`Selector`轮询到的IO事件（如`accept`、`read`、`write`）。  
  - **非IO任务**：通过`runAllTasks`处理`taskQueue`中的任务（如注册、绑定等）。  
- **执行比例**：由`ioRatio`控制，默认50，表示IO任务与非IO任务执行时间占比相等。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/f1b8027a-58fc-45a3-9283-8ec66d09145e" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/83211b14-f6f6-4b61-b1e7-48c2100da214" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/10be1c52-be8b-4b5c-8a59-6b04544fb2d5" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/52c5515c-91ad-4769-a311-c5a1560519af" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/e8d528e0-e245-4328-bec7-00a683d0bc72" />

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/f4d6a47c-f5b5-442d-a679-560e485f13c9" />

## IO事件处理（processSelectedKeys）
- **两种模式**：  
  1. 优化模式：若Netty成功优化原生`Selector`，通过`processSelectedKeysOptimized()`处理事件。  
  2. 普通模式：通过`processSelectedKeysPlain(selector.selectedKeys())`处理，与经典NIO方式一致。  
- **事件分发**：遍历`SelectionKey`，根据事件类型调用对应处理逻辑（如可读事件触发`read`操作）。  

## 数据读取流程（NioByteUnsafe.read）

1. **缓冲区分配**：通过`RecvByteBufAllocator.Handle`自适应分配`ByteBuf`大小。  

2. **数据读取**：调用`doReadBytes(byteBuf)`从原生通道读取数据到缓冲区：  
   ```java
   protected int doReadBytes(ByteBuf byteBuf) throws Exception {
       return byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());
   }
   ```

3. **事件传播**：通过`pipeline.fireChannelRead(byteBuf)`将数据传递给`ChannelPipeline`中的`ChannelHandler`处理。  


4. **续读判断**：根据缓冲区是否读满及最大读取次数（默认16次）决定是否继续读取。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/ebf0954e-6dbd-4844-bcb1-bf6ec73db6f0" />

## EventLoop的“无锁化”设计
- **串行执行**：`EventLoop`的IO事件处理和任务队列任务均在专属线程中串行执行，避免多线程竞争，无需加锁，提升性能。  

<img width="1916" height="942" alt="image" src="https://github.com/user-attachments/assets/5ef5e75f-6f1a-477a-aa83-302c673d32c1" />

一手资源:vipc9.com  
回收正版课+4767893
