1. 一段话总结：文档主要讲解了JDK动态代理和CGLIB动态代理。**JDK动态代理**通过`Proxy.newProxyInstance`生成新字节码，生成的代理对象继承`Proxy`并实现目标接口，其类名以`$Proxy`为前缀且序号递增，还通过软引用缓存优化性能；**CGLIB动态代理**通过生成目标类的子类实现代理，可代理类和接口，因能处理无接口类而补充了JDK动态代理在AOP中的不足，两者都有类似拦截处理的机制。

---

2. 思维导图：
```mindmap
## **JDK动态代理**
- 代理对象特征：继承`Proxy`、实现目标接口，类名前缀`$Proxy`且序号递增
- 字节码生成：通过`ProxyGenerator`生成字节数组，经`defineClass`（native方法）转为类
- 缓存机制：使用软引用缓存，优化性能
- 拦截机制：通过`InvocationHandler`处理方法调用
## **CGLIB动态代理**
- 代理方式：生成目标类的子类
- 适用范围：可代理类和接口
- 拦截机制：通过`MethodInterceptor`处理方法调用，需注意避免无限循环（调用`invokeSuper`）
- 与JDK动态代理对比：补充无接口类的代理需求，性能损耗略高
```

---

3. 详细总结：
### 一、JDK动态代理
1. **代理对象与类结构**
    - 生成的代理对象是全新对象，继承`Proxy`类，同时实现被代理的目标接口（支持多接口实现）。
    - 类名格式为`$Proxy`加序号（如`$Proxy0`、`$Proxy1`），序号从0开始递增，每生成一个新代理对象序号加1。
2. **字节码生成原因与过程**
    - 原因：动态代理需要一个全新的类结构来实现目标接口并完成拦截逻辑，该类结构在编译时不存在，故需动态生成。
    - 过程：通过`ProxyGenerator`生成字节数组，再调用`defineClass`（native方法）将字节码转换为类，从而创建代理对象。
3. **缓存机制**
    - 使用软引用（weak catch）进行缓存，当代理对象执行完成且不再被使用时，可释放相关资源，优化内存占用和性能。
    - 关键方法`getProxyClass0`会从缓存中获取代理类，若未命中则生成新的代理类。
4. **拦截与调用流程**
    - 代理对象的方法被调用时，会先被拦截，然后将参数通过`InvocationHandler`的`invoke`方法传递，执行最终的处理逻辑。

### 二、CGLIB动态代理
1. **代理方式与适用场景**
    - 通过生成目标类的子类实现代理，子类继承目标类并可实现目标接口。
    - 适用于无接口的类，补充了JDK动态代理只能代理接口的不足，满足AOP中对各类对象的代理需求。
2. **核心API与操作**
    - 核心API为`Enhancer`，通过它指定父类（被代理类）、接口，设置拦截器等。
    - 命名策略：生成的类名常带有`EnhanceByCGLIB`后缀，且有相应的命名规则。
3. **拦截机制与注意事项**
    - 通过`MethodInterceptor`实现方法拦截，类似JDK动态代理的`InvocationHandler`，参数包括代理对象、被拦截方法、调用参数等。
    - 注意避免无限循环：调用目标方法时需使用`invokeSuper`，而非直接调用代理对象的方法，否则会再次触发拦截。
4. **性能情况**
    - 性能损耗相对JDK动态代理略高，从示例中可见，其执行耗时比JDK动态代理更长（如示例中耗时16毫秒）。

### 三、两者对比
|特性|JDK动态代理|CGLIB动态代理|
| ---- | ---- | ---- |
|代理基础|实现目标接口|生成目标类的子类|
|适用对象|有接口的类|无接口的类、有接口的类|
|拦截机制|`InvocationHandler`|`MethodInterceptor`|
|性能损耗|相对较低|相对较高|
|类名特征|`$Proxy`+序号|带有`EnhanceByCGLIB`后缀|

---

4. 关键问题：
- 问题1：JDK动态代理生成的代理类具有哪些特征？
  答案：JDK动态代理生成的代理类继承`Proxy`类，实现被代理的目标接口（支持多接口）；类名以`$Proxy`为前缀，后面跟递增的序号（如`$Proxy0`、`$Proxy1`）；其字节码通过`ProxyGenerator`生成，经`defineClass`方法转为类。
- 问题2：为什么CGLIB动态代理能补充JDK动态代理在AOP中的不足？
  答案：JDK动态代理只能代理实现了接口的类，而在实际开发中，存在不写接口直接使用类的情况。CGLIB动态代理通过生成目标类的子类来实现代理，可对无接口的类进行代理，因此能满足AOP中对这类对象的代理需求，补充了JDK动态代理的局限。
- 问题3：JDK动态代理和CGLIB动态代理在拦截机制上有何异同？
  答案：相同点：两者都有专门的拦截处理机制，用于在方法调用时进行拦截和额外处理，拦截时都会获取代理对象、被拦截方法和调用参数等信息。不同点：JDK动态代理通过`InvocationHandler`的`invoke`方法实现拦截；CGLIB动态代理通过`MethodInterceptor`实现拦截，且调用目标方法时需使用`invokeSuper`避免无限循环，而JDK动态代理无此特殊要求。
