### Java AOP 设计模式总结

Java AOP（面向切面编程）的设计模式围绕“在不侵入目标代码的前提下，对特定行为进行增强或控制”展开，核心包含三种关键模式：代理模式、判断模式（筛选模式）、拦截模式。三者相互配合，构成了AOP的核心实现逻辑。


#### 1. 代理模式：AOP的基础载体
代理模式是AOP实现的基础，通过生成“代理对象”替代“目标对象”，从而在目标对象的方法执行前后插入额外逻辑。根据代理对象的生成时机，分为两种类型：

- **静态代理**：  
  编译期就已生成代理类的字节码文件，代理逻辑与目标对象的关系在编译时确定。  
  - 特点：代码固定，灵活性低，需手动为每个目标类编写代理类。  
  - 示例：若目标类为`UserService`，需手动创建`UserServiceProxy`，在代理类中调用`UserService`的方法，并添加前置/后置逻辑。

- **动态代理**：  
  运行时通过反射等技术动态生成代理对象，无需提前编写代理类。  
  - 特点：灵活性高，可动态为任意目标类生成代理，无需手动编码。  
  - 常见实现：Java原生的`InvocationHandler`（基于接口的动态代理）、CGLIB（基于继承的动态代理，支持类代理）。  
  - 区别：静态代理适用于固定场景，动态代理适用于通用化AOP框架（如Spring AOP）。


#### 2. 判断模式（筛选模式/选择模式）：AOP的精准定位
判断模式用于筛选“需要被拦截的目标”，即通过规则确定哪些类、方法、参数或异常需要被AOP处理。核心依赖Java反射技术，通过分析类、方法、注解、参数、异常等信息进行筛选。

- **筛选维度**：  
  - 类级别：指定拦截特定类（如`UserService`）。  
  - 方法级别：指定拦截特定方法（如`UserService.save()`）。  
  - 注解级别：通过方法上的注解筛选（如拦截标注`@Transactional`的方法）。  
  - 参数级别：根据方法参数的类型或值筛选（如拦截参数包含`userId=123`的方法）。  
  - 异常级别：根据方法声明的异常（如`throws IOException`）或执行时抛出的异常（如`NullPointerException`）筛选。  

- **应用场景**：  
  例如Spring AOP中，通过`@Pointcut`表达式定义拦截规则（如“拦截所有`service`包下带`@Log`注解的方法”），本质就是判断模式的实现。


#### 3. 拦截模式：AOP的行为增强逻辑
拦截模式定义了“拦截目标对象后执行的动作”，即通过在目标方法执行的不同阶段插入逻辑，实现增强或控制。核心包含四个阶段，覆盖方法执行的全生命周期：

- **前置阶段**：目标方法执行前触发（如参数校验、日志记录开始）。  
- **后置返回阶段**：目标方法正常执行并返回结果后触发（如记录返回值、统计执行时间）。  
- **异常阶段**：目标方法抛出异常时触发（如异常捕获、告警通知）。  
- **最终阶段**（可选）：无论方法正常返回还是抛出异常，都会执行（如资源释放）。  

- **应用场景**：  
  例如Spring的`@Before`（前置）、`@AfterReturning`（后置返回）、`@AfterThrowing`（异常）注解，就是拦截模式的具体实现。


#### 三者关系与执行流程
1. **代理模式**生成代理对象，替代目标对象对外提供服务；  
2. **判断模式**通过反射筛选出需要被拦截的目标方法（基于类、方法、注解等规则）；  
3. **拦截模式**在筛选出的目标方法执行的不同阶段（前置、后置等）插入增强逻辑。  

例如在Spring AOP中：  
- 代理模式：通过动态代理（JDK或CGLIB）生成Bean的代理对象；  
- 判断模式：通过`Pointcut`表达式筛选目标方法；  
- 拦截模式：通过`Advice`（通知）在目标方法的不同阶段执行逻辑。


总结：Java AOP的设计模式通过“代理承载-筛选定位-拦截增强”的流程，实现了对目标代码的无侵入式增强，核心依赖代理技术、反射筛选和生命周期拦截三大机制。
