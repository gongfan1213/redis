···
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.geekbang.thinking.in.spring.aop.overview;

/**
 * 静态代理示例
 *
 * @author <a href="mailto:mercyblitz@gmail.com">Mercy</a>
 * @since
 */
public class StaticProxyDemo {

    public static void main(String[] args) {
        EchoService echoService = new ProxyEchoService(new DefaultEchoService());
        echoService.echo("Hello,World");
    }
}

···


### 一段话总结：
文档围绕Java AOP代理模式展开，介绍了**静态代理**和**动态代理**两种实现手段。静态代理通过**继承与组合相结合**的方式，预先定义代理类（实现目标接口并组合目标对象）以增强功能（如计算方法执行时间）；动态代理（以**JDK动态代理**为例）通过生成新类实现，需**类加载器**、**目标接口数组**和**InvocationHandler**，可动态生成代理对象，无需预先定义代理类，灵活性更高，两者在AOP中用于方法拦截，静态代理结构固定，动态代理更适应动态增加AOP需求。


---

### 思维导图：
```mindmap
## **Java AOP代理模式**
- 静态代理
  - 实现方式：继承与组合结合（代理类实现目标接口+组合目标对象）
  - 特点：预先定义结构，修改需调整代理类，灵活性低
  - 示例：EchoService接口→DefaultEchoService实现→代理类（注入目标对象，计算执行时间）
- 动态代理
  - 类型：JDK动态代理等
  - 实现方式：通过Proxy.newProxyInstance()生成代理对象，需类加载器、接口数组、InvocationHandler
  - 特点：动态生成新类，无需预先定义代理类，灵活性高
  - 示例：生成EchoService代理，在InvocationHandler中判断方法所属接口并计算执行时间
```


---

### 详细总结：
#### 一、静态代理
1. **核心实现原理**  
   静态代理通过**继承与组合相结合**的方式实现：  
   - 代理类需实现与目标对象相同的接口（继承关系）；  
   - 代理类通过组合（如构造器注入）引入目标对象的实例，复用其原有功能；  
   - 在代理类的方法中，在调用目标对象方法的前后添加增强逻辑（如计算执行时间、打印日志等）。  

2. **示例解析**  
   - 定义接口`EchoService`，包含`echo`方法；  
   - 实现目标类`DefaultEchoService`，实现`echo`方法（返回“echo+message”）；  
   - 定义代理类（如`EchoServiceProxy`），实现`EchoService`接口，通过构造器注入`EchoService`对象；  
   - 在代理类的`echo`方法中，添加时间计算逻辑：记录开始时间→调用目标对象`echo`方法→计算耗时并输出。  

3. **特点**  
   - 结构固定：代理类需预先定义，与目标对象的接口强绑定；  
   - 灵活性低：若需修改增强逻辑或新增目标对象，需修改或新增代理类；  
   - 实现简单：基于OOP的继承和组合，易于理解和实现。  


#### 二、动态代理（以JDK动态代理为例）
1. **核心实现原理**  
   JDK动态代理通过动态生成新类实现代理功能，关键要素包括：  
   - **类加载器（ClassLoader）**：用于加载动态生成的新类（因动态代理会生成全新的字节码类），通常使用当前线程关联的上下文类加载器以保证兼容性；  
   - **目标接口数组**：指定代理类需要实现的接口（代理对象需与目标对象实现相同接口）；  
   - **InvocationHandler**：处理代理对象的方法调用，在其中实现增强逻辑（如计算执行时间），并通过反射调用目标对象的方法。  

2. **示例解析**  
   - 通过`Proxy.newProxyInstance(classLoader, new Class[]{EchoService.class}, invocationHandler)`生成`EchoService`的代理对象；  
   - 在`InvocationHandler`的`invoke`方法中：  
     - 判断当前调用的方法是否属于`EchoService`接口（通过反射API的`method.getDeclaringClass().isAssignableFrom(EchoService.class)`）；  
     - 若属于，则记录开始时间→调用目标对象的`echo`方法→计算耗时并输出。  

3. **特点**  
   - 动态生成类：无需预先定义代理类，运行时动态生成新的字节码类；  
   - 灵活性高：可通过`InvocationHandler`灵活调整增强逻辑，支持代理多个接口；  
   - 适应AOP动态需求：适合需要频繁新增或修改拦截逻辑的场景（如动态增加AOP通知）。  


#### 三、静态代理与动态代理对比表
| 对比维度       | 静态代理                     | 动态代理（JDK）               |
|----------------|------------------------------|------------------------------|
| 实现方式       | 继承+组合，预先定义代理类     | 动态生成类，依赖`Proxy`和`InvocationHandler` |
| 代理类是否预定义 | 是                           | 否                           |
| 灵活性         | 低（修改需调整代理类）       | 高（通过`InvocationHandler`动态调整） |
| 典型应用场景   | 简单固定的增强需求           | 动态AOP拦截、框架级代理（如Spring AOP） |


---

### 关键问题：
1. **静态代理的核心设计思想是什么？如何保证不破坏目标对象的原有结构？**  
   答：核心设计思想是**继承与组合相结合**。通过让代理类实现与目标对象相同的接口（继承关系），保证代理对象与目标对象的一致性；通过组合（如构造器注入）引入目标对象的实例，复用其原有功能，避免直接修改目标对象的代码，从而不破坏目标对象的静态结构。

2. **JDK动态代理中，为什么需要指定类加载器？如何选择合适的类加载器？**  
   答：因为JDK动态代理会**动态生成全新的字节码类**，类加载器的作用是将这些新生成的类装载到内存中。为确保兼容性，应选择与目标接口的类加载器一致的加载器，通常使用**当前线程关联的上下文类加载器**（`Thread.currentThread().getContextClassLoader()`）。

3. **在AOP场景中，为什么动态代理比静态代理更常用？**  
   答：因为AOP需要支持**动态增加或修改拦截逻辑**（如新增日志、事务等通知）。静态代理需预先定义代理类，修改时需调整代理类，灵活性不足；而动态代理无需预先定义代理类，可通过`InvocationHandler`动态调整增强逻辑，能适应频繁变化的AOP需求，因此更常用。
