···
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.geekbang.thinking.in.spring.aop.overview;

import org.springframework.util.ReflectionUtils;

import java.lang.reflect.Method;

/**
 * AOP 目标过滤示例
 *
 * @author <a href="mailto:mercyblitz@gmail.com">Mercy</a>
 * @since
 */
public class TargetFilterDemo {

    public static void main(String[] args) throws ClassNotFoundException {
        String targetClassName = "org.geekbang.thinking.in.spring.aop.overview.EchoService";
        // 获取当前线程 ClassLoader
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        // 获取目标类
        Class<?> targetClass = classLoader.loadClass(targetClassName);
        // 方法定义：String echo(String message);
        // Spring 反射工具类
        Method targetMethod = ReflectionUtils.findMethod(targetClass, "echo", String.class);
        System.out.println(targetMethod);

        // 查找方法  throws 类型为 NullPointerException
        ReflectionUtils.doWithMethods(targetClass, new ReflectionUtils.MethodCallback() {
            @Override
            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {
                System.out.println("仅抛出 NullPointerException 方法为：" + method);
            }
        }, new ReflectionUtils.MethodFilter() {
            @Override
            public boolean matches(Method method) {
                Class[] parameterTypes = method.getParameterTypes();
                Class[] exceptionTypes = method.getExceptionTypes();
                return parameterTypes.length == 1
                        && String.class.equals(parameterTypes[0])
                        && exceptionTypes.length == 1
                        && NullPointerException.class.equals(exceptionTypes[0]);
            }
        });
    }
}

···

### 一段话总结：
本文围绕**Java AOP判断模式（Predicate）** 展开，核心是介绍如何**筛选Join Point**。通过**Java反射机制**（结合Spring反射工具类），可对类和方法进行过滤：类的筛选主要依据**全类名**，通过类加载器加载目标类；方法的筛选可通过**方法名称、参数类型、异常类型**等维度，例如通过方法名和参数类型查找目标方法，或通过异常类型（如`NoPointException`）筛选特定方法，还可扩展正则表达式等规则，为AOP中的拦截行为提供判断依据。


---

### 思维导图：
```mindmap
## **Java AOP判断模式（Predicate）**
- 核心目标：筛选Join Point
- 实现基础：Java反射机制 + Spring反射工具类（如ReflectionUtility）
- 筛选维度
  - 类的筛选
    - 依据：全类名
    - 操作：通过类加载器（ClassLoader）加载目标类
  - 方法的筛选
    - 依据1：方法名称 + 参数类型
    - 依据2：异常类型（如NoPointException）
    - 扩展：正则表达式等自定义规则
- 示例操作
  - 加载目标类（如EchoService）
  - 查找方法（通过名称、参数类型）
  - 筛选特定异常的方法（如仅抛出NoPointException的方法）
```


---

### 详细总结：
#### 一、主题与核心目标
- 主题：**Java AOP判断模式（Predicate）**  
- 核心目标：解决如何**筛选Join Point**（即确定AOP中需要拦截的类或方法），为后续拦截行为提供判断依据。


#### 二、实现基础
- 依赖**Java反射机制**：通过反射API获取类、方法的元信息（如类名、方法名、参数、异常等），实现对类和方法的过滤。  
- 结合**Spring反射工具类**：如`ReflectionUtility`，简化类和方法的查找、筛选操作。


#### 三、类的筛选
1. **筛选依据**：主要通过**全类名**确定目标类，全类名可唯一标识一个类。  
2. **操作步骤**：  
   - 获取类加载器（ClassLoader）：通常使用当前上下文类加载器，确保与目标类的类加载器兼容；  
   - 加载目标类：通过`classLoader.loadClass(全类名)`加载类，若类不存在则抛出`ClassNotFoundException`；  
   - 示例：加载`EchoService`类时，通过其全类名，使用类加载器加载得到对应的`Class`对象。  


#### 四、方法的筛选
方法筛选需结合类的信息（先确定类，再查找方法），主要维度如下：

| 筛选维度       | 说明                                                                 | 示例操作                                                                 |
|----------------|----------------------------------------------------------------------|--------------------------------------------------------------------------|
| 方法名称 + 参数类型 | 同一接口中，方法名和参数类型可唯一确定方法（方法签名唯一性）           | 使用`ReflectionUtility.findMethod(目标类, 方法名, 参数类型数组)`查找目标方法，如查找`EchoService`中名称为`echo`、参数为`String`类型的方法。 |
| 异常类型       | 通过方法声明的异常类型筛选，可指定异常数量和具体类型                 | 筛选仅抛出1个`NoPointException`的方法：判断方法的`exceptionTypes`长度为1，且第一个类型为`NoPointException`。 |
| 扩展规则       | 可自定义规则（如正则表达式匹配方法名），类似AspectJ的判断方式         | 例如通过正则表达式匹配方法名包含“echo”的方法。                             |

3. **示例流程**：  
   - 定义目标方法：如`EchoService`中返回值为`String`、参数为`String`、可能抛出`NoPointException`的`echo`方法；  
   - 查找方法：通过`ReflectionUtility`根据方法名和参数类型找到该方法；  
   - 筛选异常：使用`doWithMethod`回调，过滤出仅抛出`NoPointException`的方法，并打印其签名验证结果。  


#### 五、总结
Java AOP判断模式通过反射和工具类，从**类（全类名）** 和**方法（名称、参数、异常等）** 维度筛选Join Point，支持灵活扩展规则，为AOP的拦截逻辑提供精准的判断依据。


---

### 关键问题：
1. **在Java AOP判断模式中，筛选类的核心依据是什么？如何确保成功加载目标类？**  
   答：核心依据是**类的全类名**（可唯一标识类）。为确保加载成功，需使用与目标类兼容的类加载器（通常为当前线程关联的上下文类加载器），通过`classLoader.loadClass(全类名)`方法加载，若类不存在会抛出`ClassNotFoundException`。

2. **筛选方法时，可通过哪些具体维度进行过滤？请结合文档示例说明其中一种方式。**  
   答：可通过**方法名称、参数类型、异常类型**等维度过滤。例如筛选特定异常类型的方法：文档中通过判断方法的`exceptionTypes`（异常类型数组）长度为1，且第一个类型为`NoPointException`，从而筛选出仅抛出该异常的方法。

3. **反射机制在Java AOP判断模式中起到什么作用？为何要结合Spring的反射工具类？**  
   答：反射机制的作用是**获取类和方法的元信息**（如类名、方法名、参数、异常等），为筛选Join Point提供数据支持。结合Spring反射工具类（如`ReflectionUtility`）可简化操作，例如`findMethod`方法能快速根据方法名和参数类型查找方法，减少重复编码，提高效率。
