### 混合型任务线程池的线程数配置

#### 一、混合型任务的特点
混合型任务兼具**CPU计算**和**IO操作**（如数据库访问、远程服务调用等），其特点是：  
- 任务执行过程中既有CPU密集型操作（如逻辑计算），也有耗时的IO操作（如网络请求、磁盘读写）；  
- CPU利用率介于IO密集型和CPU密集型任务之间，受IO操作耗时影响较大；  
- 典型场景：Tomcat处理HTTP请求（需解析请求、计算业务逻辑，同时可能调用数据库或其他微服务）。  


#### 二、线程数估算公式（理论最佳值）
混合型任务的线程数需结合**CPU时间**和**IO等待时间**估算，公式如下：  
```
最佳线程数 =（线程等待时间 + 线程CPU时间）/ 线程CPU时间 × CPU核心数  
```  
- **线程等待时间**：任务中IO操作的耗时（如数据库查询、远程调用等）；  
- **线程CPU时间**：任务中纯计算的耗时；  
- **CPU核心数**：运行环境的CPU核心数量。  

**示例**：  
假设某任务的IO等待时间为900ms，CPU计算时间为100ms，运行在8核CPU上：  
```
最佳线程数 =（900 + 100）/ 100 × 8 = 10 × 8 = 80  
```  


#### 三、实际配置注意事项
1. **公式的参考性**  
   公式为理论值，实际需结合业务场景调整。例如：  
   - 若一次请求涉及2次数据库调用（每次300ms）+ 100ms CPU计算，则等待时间=600ms，CPU时间=100ms，8核CPU下估算线程数为 `(600+100)/100×8=56`。  
   - 线程数并非越多越好，过多会导致线程切换开销激增，反而降低效率。  

2. **核心参数配置**  
   混合型线程池的配置与IO/CPU密集型类似，核心差异在于**线程数计算**，其他参数包括：  
   - **核心线程数=最大线程数**：避免频繁创建/销毁线程，优先利用现有线程；  
   - **有界队列**：使用`LinkedBlockingQueue`并指定容量（如1024），防止任务积压导致OOM；  
   - **允许核心线程超时销毁**：通过`allowCoreThreadTimeOut(true)`释放长期空闲资源；  
   - **自定义线程工厂**：指定线程名称（如`mixed-pool-1`），便于问题排查；  
   - **JVM关闭钩子**：注册钩子函数，确保线程池优雅关闭。  


#### 四、参考代码实现
```java
public class MixedTaskThreadPool {
    // 静态内部类实现懒汉单例（线程安全）
    private static class LazyHolder {
        // 从环境变量获取线程数，默认值为CPU核心数×5（示例）
        private static final int THREAD_COUNT = Integer.getInteger(
            "mixed.thread.pool.size",
            Runtime.getRuntime().availableProcessors() * 5
        );
        // 有界队列容量
        private static final int QUEUE_SIZE = 1024;
        // 空闲线程存活时间（秒）
        private static final long KEEP_ALIVE_SECONDS = 60;

        // 初始化混合型线程池
        private static final ThreadPoolExecutor INSTANCE = new ThreadPoolExecutor(
            THREAD_COUNT,
            THREAD_COUNT,
            KEEP_ALIVE_SECONDS,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(QUEUE_SIZE),
            new CustomThreadFactory("mixed"), // 自定义线程工厂
            new CustomRejectedHandler() // 自定义拒绝策略
        );

        static {
            // 允许核心线程超时销毁
            INSTANCE.allowCoreThreadTimeOut(true);
            // 注册JVM关闭钩子，优雅关闭线程池
            Runtime.getRuntime().addShutdownHook(new Thread(INSTANCE::shutdown));
        }
    }

    // 获取单例实例
    public static ThreadPoolExecutor getInstance() {
        return LazyHolder.INSTANCE;
    }

    // 私有构造器防止实例化
    private MixedTaskThreadPool() {}
}
```


#### 五、应用场景与优化
- **典型场景**：Web服务器（如Tomcat）、微服务网关、业务服务中的任务处理等。  
- **优化建议**：  
  1. 通过监控工具（如JProfiler）统计实际任务的CPU时间和IO等待时间，动态调整线程数；  
  2. 避免线程数硬编码，可通过配置中心（如Nacos）动态修改；  
  3. 结合业务拆分线程池（如读写分离），避免IO任务阻塞CPU任务。  

混合型线程池的核心是**平衡CPU利用率和IO等待效率**，通过理论公式结合实际监控，实现线程数的合理配置。


# 混合型线程池的线程数配置
一手微4767893  
送课+微4767893  

## Tomcat服务器的线程池的特点
混合型任务线程池  

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/62729269-5d4b-4348-b7b0-574072b11ce9" />


## 混合型任务创建线程池时，如何确定线程数
业界有一个比较成熟的估算公式：  

最佳线程数 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU核数  

经过简单的换算，以上公式可进一步转换为：  

最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1) * CPU核数  

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/57e3aa01-8a79-40b7-8122-4594fe5d5ae2" />


## 例子
比如在web服务器处理HTTP请求时，假设平均线程CPU运行时间为100ms，而线程等待时间（比如包括DB操作、RPC操作、缓存操作等）为900ms，如果CPU核数为8，那么根据上面这个公式，估算如下：  

(900ms + 100ms) / 100ms * 8 = 10 * 8 = 80  

经过计算，以上案例中需要的线程数为80  



## 线程数并非越高越好

很多的小伙伴认为，线程数越高越好。  

那么，使用很多线程是否就一定比单线程高效呢？  

答案是否定的，比如大名鼎鼎的Redis就是单线程的，但它却非常高效，基本操作都能达到十万量级/秒。  


## 说明
以上公式的估算结果，仅仅是理论最佳值，在生产环境使用也仅供参考。  

生产环境需要结合系统网络环境和硬件情况（CPU、内存、硬盘读写速度）不断尝试，获取一个符合实际的线程数值。  

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/5a4300d9-7e01-4840-82d1-be76ddfe7bae" />

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/d2c13aca-6d0f-4b9b-b818-692aa32bb626" />


1. 通过环境变量或启动参数设定混合型线程池的线程数，根据代码估算结果进行配置，若未设置则提供默认值。

2. 封装混合型线程池的获取方法至内部类中，采用懒汉单例模式实现，确保线程池的高效复用。

3. 创建有界队列，自定义线程工厂，并修改线程名称，确保线程池参数的一致性和可定制性。

4. 允许核心线程关闭，并在JVM退出时自动关闭混合型线程池，避免资源泄露，提高系统稳定性。

5. 通过模拟示例，展示如何在代码中实现混合型线程池的创建与管理，包括环境变量获取、线程池配置及关闭机制。


## 混合型任务线程池参考代码
```java
// 首先从环境变量 mixed.thread.amount 中获取预先配置的线程数
// 如果没有对 mixed.thread.amount 做配置，则使用常量 MIXED_MAX 作为线程数
private static final int max = (null != System.getProperty(MIXED_THREAD_AMOUNT)) ?
    Integer.parseInt(System.getProperty(MIXED_THREAD_AMOUNT)) : MIXED_MAX;

// 线程池：用于混合型任务
private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor(
    max,
    max,
    KEEP_ALIVE_SECONDS,
    TimeUnit.SECONDS,
    new LinkedBlockingQueue(QUEUE_SIZE),
    new CustomThreadFactory("mixed")
);
```
<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/c574dda6-36be-420e-a97b-b00cb6933280" />


## 懒汉式单例创建线程池（用于混合型任务）代码片段
```java
private static class MixedTargetThreadPoolLazyHolder {
    // 首先从环境变量 mixed.thread.amount 中获取预先配置的线程数
    // 如果没有对 mixed.thread.amount 做配置，则使用常量 MIXED_MAX 作为线程数
    private static final int max = (null != System.getProperty(MIXED_THREAD_AMOUNT)) ?
        Integer.parseInt(System.getProperty(MIXED_THREAD_AMOUNT)) : MIXED_MAX;

    // 线程池：用于混合型任务
    private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor(
        max,
        max,
        KEEP_ALIVE_SECONDS,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue(QUEUE_SIZE),
        new CustomThreadFactory(threadTag: "mixed")
    );

    static {
        // 此处可添加核心线程超时销毁、注册JVM关闭钩子等操作
    }
}
```

一手资源:vipc9.com  
送课+微4767893
