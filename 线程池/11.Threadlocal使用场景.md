### ThreadLocal（线程本地变量）核心知识总结

#### 一、什么是ThreadLocal
ThreadLocal（线程本地变量）是一种为每个线程保存独立值的变量类型，每个线程操作的都是自己的专属副本，线程间互不干扰。  
- 特点：无需加锁即可保证线程安全，是“无锁编程”的重要方案（通过空间换安全）。  
- 核心原理：可理解为内部维护了一个“线程-值”的映射（JDK 1.8后优化了结构，但逻辑上仍可这么理解），线程通过`get()`获取自己的副本，通过`set()`修改，通过`remove()`清理。


#### 二、核心方法
1. **`set(T value)`**：为当前线程绑定一个值。  
2. **`get()`**：获取当前线程绑定的值（若未初始化，需手动设置或通过`initialValue()`初始化）。  
3. **`remove()`**：移除当前线程绑定的值（避免内存泄漏，非常重要）。  


#### 三、初始化方式
1. **手动`set()`**：直接调用`set()`方法设置初始值。  
2. **`initialValue()`**：通过匿名函数初始化，当`get()`时若值为`null`，会自动调用该方法创建值：  
   ```java
   ThreadLocal<Foo> local = ThreadLocal.withInitial(() -> new Foo());
   ```


#### 四、使用示例
```java
// 定义ThreadLocal（通常用private static final修饰）
private static final ThreadLocal<Foo> localFoo = ThreadLocal.withInitial(Foo::new);

// 线程池提交任务
executor.submit(() -> {
    Foo foo = localFoo.get(); // 获取当前线程的副本
    for (int i = 0; i < 10; i++) {
        foo.increment(); // 操作副本，线程安全
    }
    System.out.println(foo.getValue()); // 每个线程结果独立
    localFoo.remove(); // 清理副本，避免内存泄漏
});
```
- 结果：每个线程的操作仅影响自己的副本，无需加锁即可保证线程安全。


#### 五、典型应用场景
1. **线程隔离**  
   避免多线程操作共享资源时的线程安全问题，例如数据库连接独享：  
   - Hibernate中通过`ThreadLocal`绑定`Session`，确保一个线程使用一个独立的数据库连接，避免事务混乱。  

2. **跨函数数据传递**  
   替代参数传递，在多层函数调用中共享数据（如Web应用中的用户会话）：  
   - 在过滤器中把`Session`存入`ThreadLocal`，后续任意函数可通过`get()`直接获取，无需层层传递参数。  


#### 六、关键注意事项
- **修饰符**：通常用`private static final`修饰，避免被意外修改或实例化多个副本。  
- **内存泄漏**：使用后必须调用`remove()`清理副本，否则线程池中的线程可能长期持有值，导致内存泄漏。  


#### 总结
ThreadLocal通过为每个线程维护独立副本，实现了无锁的线程安全，主要用于线程隔离和跨函数数据传递。合理使用可简化多线程编程，提升性能，但需注意及时清理副本以避免内存问题。

# ThreadLocal的使用场景
一手资源:vipc9.com  
送课+微4767893  

## 什么是ThreadLocal
在 Java 的多线程并发执行过程中，为保证多个线程对变量的安全访问，可以将变量放到 ThreadLocal 类型的对象中，使变量在每个线程中都有独立值，不会出现一个线程读取变量时而被另一个线程修改的现象。ThreadLocal 类通常被翻译为“线程本地变量”类，或者“线程局部变量”类。

## ThreadLocal的功能之一：无锁编程的实现方案
“线程本地变量”可以看成专属于线程的变量，不受其他线程干扰，保存着线程的专属数据。当线程结束后，每个线程所拥有的那一个本地值也会被释放。在多线程并发操作“线程本地变量”时候，线程各自操作的是自己的本地值，从而规避了线程安全问题。

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/a0197d7e-019a-4108-82f2-9bf5724e1776" />

1. 线程本地变量可理解为一个map，每个线程对应一个独立的变量副本，确保线程安全。

2. 通过空间换取安全，每个线程在取值时获取的是自己那一份，避免了线程间的数据冲突。

3. JDK早期版本采用类似map的结构实现线程本地变量，但JDK1.8对此进行了优化。

4. 优化后的实现细节虽未提及，但理解为map结构对于概念掌握是有效的。

5. 此解释方式有助于形象理解线程本地变量的运作机制及其设计初衷。



## ThreadLocal变量如何每个线程存有一份独立的本地值
一个ThreadLocal实例可以形象地理解为一个Map（早期版本的ThreadLocal是这样设计的）：
| KEY       | VALUE         |
|-----------|---------------|
| Thread A  | Local Value A |
| Thread B  | Local Value B |
| ...       | ...           |
| Thread N  | Local Value N |

## ThreadLocal的成员方法进行本地值操作
| 方法           | 说明                                                 |
|----------------|------------------------------------------------------|
| set(T value)   | 设置当前线程在“线程本地变量”实例中绑定的本地值       |
| T get()        | 获得当前线程在“线程本地变量”实例中绑定的本地值       |
| remove()       | 移除当前线程在“线程本地变量”实例中绑定的本地值       |

## 定义一个简单的POJO对象，用于ThreadLocal存储演示
```java
public class ThreadLocalTest {
    @Data
    static class Foo {
        // 实例总数
        static final AtomicInteger AMOUNT = new AtomicInteger(initialValue: 0);
        int index = 0; // 对象的编号
        int bar = 10; // 对象的内容

        // 构造器
        public Foo() {
            index = AMOUNT.incrementAndGet(); // 总数增加，并且给对象的编号
        }

        @Override
        public String toString() {
            return index + "@Foo(bar=" + bar + ')';
        }
    }
}
```

## 创建一个ThreadLocal本地变量
```java
// 线程本地变量
private static final ThreadLocal<Foo> LOCAL_FOO = new ThreadLocal<Foo>();

public void test(String[] args) throws InterruptedException {
    ThreadLocal<Foo> localFoo = ThreadLocal.withInitial(() -> new Foo());
    // 获取自定义的混合线程池
}
```

## ThreadLocal本地变量的设值和取值
```java
// 获取“线程本地变量”中当前线程所绑定的值
if (LOCAL_FOO.get() == null) {
    // 设置“线程本地变量”中当前线程所绑定的值
    LOCAL_FOO.set(new Foo());
}
```

## 源码案例
- demo：对应于书的内容 1.8.1  
- 源码工程：https://gitee.com/crazymaker/Java-high-concurrency-core-Programming-Volume-2-source-code.git  
- 源码案例：testThreadLocal  

## ThreadLocal本地变量初始化方案（两种）

1. 线程本地变量的概念，即每个线程拥有独立的值，相当于线程的私有财产，确保数据隔离和线程安全。

2. 手动初始化方案，通过setter方法为线程本地变量设置初始值，提供灵活的初始化时机和方式。

3. 使用静态方法初始化，通过匿名函数在获取变量时自动创建新值，实现更简洁的初始化逻辑。

1. 判空后设值：
```java
// 获取“线程本地变量”中当前线程所绑定的值
if (LOCAL_FOO.get() == null) {
    // 设置“线程本地变量”中当前线程所绑定的初始值
    LOCAL_FOO.set(new Foo());
}
```
2. 使用ThreadLocal.withInitial(...)静态工厂方法：
```java
ThreadLocal<Foo> LOCAL_FOO = ThreadLocal.withInitial(() -> new Foo());
```
在当前线程尚未绑定值时，如果希望能从线程本地变量获取到初始值，且不想采用“判空后设值”这种相对繁琐的方式，可使用此方法，在定义ThreadLocal对象时设置一个获取初始值的回调函数。

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/b2871e43-0146-4cd0-8b10-1b2741e2b406" />


## ThreadLocal本地变量使用场景
1. 线程隔离  

2. 跨函数传递数据  


## 线程隔离，作为无锁编程的重要方式
ThreadLocal 在“线程隔离”应用场景的典型应用为“数据库连接独享”。下面的代码来自 Hibernate，代码中通过 ThreadLocal 进行数据库连接(Session)的“线程本地化”存储，主要的代码如下：
```java
private static final ThreadLocal threadSession = new ThreadLocal();

public static Session getSession() throws InfrastructureException {
    Session s = (Session) threadSession.get();
    try {
        if (s == null) {
            s = getSessionFactory().openSession();
            threadSession.set(s);
        }
    } catch (HibernateException ex) {
        throw new InfrastructureException(ex);
    }
    return s;
}
```
<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/032b8907-ea37-4333-acee-1569667613f3" />

1. 本地变量用于线程隔离，避免锁的使用，每个线程拥有独立的本地变量副本，确保线程间操作独立性。

2. 本地变量作为跨函数传递数据的手段，减少参数传递的复杂性，特别是在参数为公共或需频繁传递时。

3. 线程隔离示例中，ThreadLocal确保每线程独立操作，避免共享资源冲突。

4. 数据库连接独享场景，本地变量可存储每个线程的独立数据库连接，提高并发操作的安全性和效率。

5. 通过本地变量实现数据隔离和跨函数传递，优化多线程编程中的资源管理和数据交互。


## ThreadLocal进行跨函数数据传递
ThreadLocal 在“跨函数数据传递”应用场景的典型有很多：  

1. 用来传递请求过程中的用户ID。  

2. 用来传递请求过程中的用户会话（Session）。  

3. 用来传递 HTTP 的用户请求实例 HttpRequest。  

4. 其他需要在函数之间频繁传递的数据。

1. 传递公共数据时，使用函数参数会增加代码复杂度，如用户ID和绘画数据的传递，而ThreadLocal可以在同一线程内共享数据，减少参数传递。


2. ThreadLocal适用于在多个函数间传递数据，特别是在需要跨函数调用记录时间等场景，避免了每个函数都需要传递时间参数的繁琐。

3. 使用ThreadLocal可以简化代码结构，特别是在长链调用中，从最开始的函数记录开始时间，到最后一个函数获取并计算结束时间，无需在每个函数间传递时间参数。

4. 对比函数参数传递，ThreadLocal在处理公共数据传递时更高效，尤其在需要在多个相关函数间共享数据的场景下，能显著减少代码冗余和提高可读性。

5. ThreadLocal机制在Java等语言中被广泛应用，通过为每个线程提供独立的变量副本，确保了线程安全，同时也方便了跨函数的数据传递和管理。



<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/23637a6b-f7dc-4eb8-8e37-b1b0dab5904b" />

1. 数据库连接在多线程环境下的独享至关重要，避免事务混乱，确保每个线程使用独立的连接，实现线程安全。

2. Hibernate框架通过ThreadLocal机制实现连接的线程隔离，保证每个线程独享一个Session对象，从而使用同一个数据库连接，避免资源冲突。

3. 当线程首次请求Session时，Hibernate会从连接池中获取一个连接并绑定到当前线程，后续请求将直接从ThreadLocal中获取，确保连接的连续性和一致性。

4. ThreadLocal机制不仅解决了多线程环境下数据库连接的管理问题，还简化了跨函数数据传递的复杂性，提高了代码的可读性和维护性。

5. 通过Hibernate的Session管理，开发者无需手动管理数据库连接的生命周期，实现了连接的自动获取和释放，增强了应用程序的稳定性和效率。



### 示例：web应用中的本地session
```java
public class SessionHolder {
    // session 线程本地变量
    private static final ThreadLocal<HttpSession> sessionLocal = new NamedThreadLocal<>("sessionLocal");

    /**
     * 保存session
     * @param session 待保存的session
     */
    public static void setSession(HttpSession session) {
        sessionLocal.set(session);
    }

    /**
     * 清除线程局部变量
     */
    public static void clearData() {
        sessionLocal.remove();
    }

    /**
     * 取得session
     * @return 返回session
     */
    public static HttpSession getSession() {
        HttpSession session = sessionLocal.get();
        Assert.notNull(session, "session 未设置");
        return session;
    }
}
```

```java
@Slf4j
public class SessionDataLoadFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {
        // 获取前面的 SessionIdFilter 过滤器加载的 session id
        /**
         * 将Session请求，保持到 SessionHolder 的 ThreadLocal 本地变量中，方便统一获取
         */
        SessionHolder.setSession(session);
        filterChain.doFilter(request, response);
    }
}
```
1. 本地上定义的section可实现线上隔离及跨函数传递，具体到用户一次HTTP请求中，利用thread local子类如HD station本地变量，可存储和清除特定值，有效隔离不同请求间的变量影响。

2. 过滤器机制的引入，为web应用中section的使用提供了更灵活的控制手段，通过定义在过滤器中的方法，可实现在请求处理流程中的特定操作，如变量的存储和清除，增强应用的可维护性和扩展性。

3. 通过实例化thread local子类，如HD station，可以为每个线程或每个用户请求创建独立的变量存储空间，避免了多线程环境下的变量冲突，确保了数据的一致性和安全性。

4. 在web应用设计中，将section概念用于用户请求的隔离，结合thread local机制，不仅实现了线上环境的隔离，还通过跨函数传递功能，简化了不同处理阶段间数据的传递过程，提高了开发效率。

5. 利用定义在过滤器中的方法，如存储和清除特定值的操作，可以有效管理section中的变量，确保在处理完一次请求后，相关资源得到及时释放，避免了内存泄漏，提升了应用的性能和稳定性。

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/f1771dc6-ba4f-4ecc-8c21-650bda62561d" />


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/e2dda299-0994-4799-be93-61d2bba6b7fe" />


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/1bf80b7e-0bcd-4fd7-ae4c-4e6045659914" />

1. 通过get方法直接获取session，避免了数据传递的繁琐，方便跨函数使用用户ID等信息，提升开发效率。

2. session机制作为本地变量的替代，实现跨函数数据传递，同时保证了信息的安全性，增强了系统稳定性。

3. web station的源码保存在本地电脑，位于spring cloud的高并发编程核心源码库中，便于开发者查找和使用。

4. 在spring cloud框架下，通过合理利用session和源码管理，可以有效提升系统的并发处理能力和开发维护效率。

5. 强调了在高并发编程中，合理利用session和优化源码管理对于提升系统性能和开发效率的重要性。

Thank you  
一手资源:vipc9.com  
回收正版课+4767893
