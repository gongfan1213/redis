<img width="705" height="191" alt="image" src="https://github.com/user-attachments/assets/3f432d35-bff6-4571-bc16-1d7baacf9a80" />


# Thread
Thread 类是java语言的一个重要的基础类，位于java.lang包当中

 Thread类用于存储和操作线程的描述信息有不少非常重要属性

 <img width="647" height="498" alt="image" src="https://github.com/user-attachments/assets/1e1a930b-e02a-456a-8a6d-bcbac9c65b5a" />

target执行目标

<img width="364" height="458" alt="image" src="https://github.com/user-attachments/assets/58f9d40c-15b5-4b58-9d7e-462a60d787fa" />


if(tagrte !=nul) target = 
## 继承Thread类创建线程类，需要做以下两件事情：

- 1.需要继承Thread类，创建一个新的线程子勒
- 2.同时重写run（）方法，将需要并发执行业务代码编写在run方法当中

# 创建方法2:实现Runnable接口创建线程目标类，然后创建线程实例

实现runnable接口，将需要一步执行的业务逻辑代码放到runnable类的run方法题当中，将runnable实例作为tagret执行目标传入到thread实例当中

1.定义一个新类实现runnable接口

2.实现runnable接口的run()抽象方法，将线程代码逻辑存放到在run实现版本当中

3.通过thread类创建线程对象，将runnable实现类实例，作为实际参数传递给thread类的构造器当中，由thread构造器将改runnable实例赋值给自己的tagret执行目标属性

4.调用Thread实例的start方法，开启线程

```
  for(int i = 0; i < 10; i++){
    threac = new Thread(() -> {
      for(int j = 0; j < 1000000000; j++){
        System.out.println("1111111");
      }
    });
    thread.start();
  }
```
# 创建线程方法3:使用callable和FutureTask创建线程

### runnable异步任务的问题：
不能获取异步执行目标的结果

不能取消异步执行的任务

- 解决方法

- 使用可以进行管理的异步任务相关类：Future接口和FutureTask类型

<img width="549" height="493" alt="image" src="https://github.com/user-attachments/assets/965854b5-e37a-409b-b59a-520319464836" />



Future 都处于异步执行目标角色，Thread的 target 角色。

对 Future 接口的主要方法，详细说明如下： 
- V get(): 获取异步任务执行的结果。注意，这个方法的调用是阻塞性的。如果异步任务没有执行完成，异步结果获取线程（调用线程）会一直被阻塞，一直阻塞到到异步任务执行完成，其异步结果返回给调用线程。 
- V get(Long timeout, TimeUnit unit) : 设置时限，（调用线程）阻塞性的获取异步任务执行的结果。该方法的调用也是阻塞性的，但是结果获取线程（调用线程）会有一个阻塞时长限制，不会无限制的阻塞和等待，如果其阻塞时间超过设定的 timeout 时间，该方法将抛出异常，调用线程可捕获此异常。 
- boolean isDone(): 获取异步任务的执行状态。如果任务执行结束，返回 true。 
- boolean isCancelled(): 获取异步任务的取消状态。如果任务完成前被取消，则返回 true。
- boolean cancel(boolean mayInterruptRunning): 取消异步任务的执行。 



FutureTask 的内部成员 Callable 对象
与runnable一样，用于封装异步的业务逻辑。

1. Callable 接口

Callable 接口位于 java.util.concurrent 包中，翻开 Java 源代码，Callable 的代码如下：
```
package java.util.concurrent;
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```
Callable 接口是一个泛型接口，也是一个“函数式接口”。其唯一的抽象方法 call（）有返回值，返回值的类型为 Callable 接口的泛型形参类型；call 抽象方法还有一个 Exception 的异常声明，容许方法的实现版本内部的异常直接抛出，并且可以不予捕获。

Callable 接口类似于 Runnable。不同的是，Runnable 的唯一抽象方法 run（）没有返回值，也没有受检异常的异常声明。比较而言，Callable 接口的 call（）有返回值有返回值，并且申明了受检异常，其功能更强大一些。 


以下是提取的文字内容：

5. 使用 Callable 和 FutureTask 创建线程的具体步骤

通过 FutureTask 类和 Callable 接口的联合使用，可以创建能获取异步执行结果的线程。具体的步骤如下：


（1）创建一个 Callable 接口的实现类，并实现其 call()方法，编写好异步执行的具体逻辑，并且可以有返回值。 

（2）使用 Callable 实现类的实例，构造一个 FutureTask 实例。 

（3）使用 FutureTask 实例，作为 Thread 构造器的 target 入参，构造新的 Thread 线程实例； 

（4）调用 Thread 实例的 start 方法启动新线程，启动新线程的 run()方法并发执行。其内部的执行过程为：启动 Thread 实例的 run()方法并发执行后，会执行 FutureTask 实例的 run()方法，最终会并发执 Callable 实现类的 call()方法。 

（5）调用 FutureTask 对象的 get()方法，阻塞性的获得并发线程的执行结果。 


<img width="670" height="313" alt="image" src="https://github.com/user-attachments/assets/e81e6848-c47d-4bc2-a7ce-c67f13c05fa1" />



FutureTask可以处于以下三种执行状态：

1、未启动：在FutureTask.run()还没执行之前，FutureTask处于未启动状态。当创建之后，并且run执行前。 2、已启动：FutureTask对象的run方法启动并执行的过程中，FutureTask处于已启动状态。 3、已完成：FutureTask正常执行结束，或者FutureTask执行被取消（FutureTask对象candel方法），或者FutureTask对象run方法执行抛出异常而导致中断而结束，FutureTask都处于已完成状态。

获取异步任务的结果

<img width="650" height="272" alt="image" src="https://github.com/user-attachments/assets/f7b636f8-84df-4a49-aefe-401fdbe8a089" />


<img width="750" height="508" alt="image" src="https://github.com/user-attachments/assets/2b9068d0-dc49-44a2-9d0d-8482b6ebb3b0" />




# 1.3.8 线程创建方法四：通过线程池创建线程

前面的示例中，所创建的 Thread 实例在执行完成之后都销毁了，这些线程实例都是不可用复用的。实际上创建一个线程实例在时间成本、资源耗费上都很高的（稍后会介绍到），在高并发的场景中，断然不能频繁进行线程实例的创建与销毁，而是需要对已经创建好的线程实例进行复用，这就涉及到线程池的技术。Java 中提供了一个静态工厂来创建不同的线程池，该静态工厂为：Executors 工厂类。

