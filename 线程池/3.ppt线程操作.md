# 揭秘:Java线程的生命周期与基本操作

本视频主要内容:  
- 线程的调度模型:分时调度模型、抢占式调度  
- 线程的生命周期状态  
- 三种基础状态的转换关系  
- WAITING&TIMED WAITING、B1ock阻塞状态的入口条件  
- start和run方法的区别  
 

## 线程的调度模型  
目前主要分为两种调度模型:分时调度模型、抢占式调度模型。  
- 分时调度模型  
平均分配CPU时间片,每个线程占有的cpu时间片长度一样,平均分配,一切平等  
- 抢占式调度模型  
哪个线程的优先级比较高,抢到的cpu时间片的概率就大。java采用的就是抢占式调度模型。  


### 分时调度示意图  
一手微4767893  
图1-10就是一个分时调度的简单例子:三个线程,轮流得到CPU时间片:一个线程执行时, 另外两个线程处于就绪状态。  

<img width="563" height="325" alt="image" src="https://github.com/user-attachments/assets/f57cf95e-995b-4e82-93a9-bd436454a3c7" />

图1-10三个线程的分时调度模型示意图~  


1. 在线程执行过程中,会涉及到线程的不断切换,例如当线程一在执行时,线程二和线程三处于就绪状 态｡  

2. 这种轮流执行的调度方式,用黄色表示执行状态,白色表示就绪状态,被称为分时调度模式,是一种 非常平均的调度方式｡  

3. 分时调度模式是一种原始的调度方式,存在明显的问题,因为它没有考虑到线程的优先级,所有线程 被视为同等重要｡  

4. 在实际操作中,线程的优先级是有差异的,有的线程优先级高,有的线程优先级低,这在原始的分时 调度模式中并未得到体现和处理｡  



### 抢占式调度模型  
(2)抢占式调度模型--系统按照线程优先级分配CPU时间片。优先级高的线程,优先分 配CPU时间片:如果所有的就绪线程的优先级相同,那么会随机选择一个:优先级高的线程获取 的CPU时间片相对多一些。  

由于目前大部分操作系统都是使用抢占式调度模型进行线程调度。Java的线程管理和调度是 委托给了操作系统完成的,与之相对应,Java的线程调度也是使用抢占式调度模型。所以,Java 的线程都有优先级。  

 

1. 抢占式调度模式确保优先级高的线程优先执行,这意味着CPU时间片分配给优先级高的线程更多｡  
2. 线程的调度由操作系统内核完成,因此Java线程的调度也是委托给操作系统处理｡  
3. 操作系统采用的调度模型是抢占式,这直接影响了Java线程的执行顺序和时间分配｡  
4. Java线程具有优先级,这一特性使得在多线程环境中,高优先级的线程能够获得更多的执行机会｡  

## 线程的优先级  

# 1.4.2线程的优先级  
在Thread类中有一个实例属性和两个实例方法,专用于进行线程优先级相关的操作,与线程 优先级相关的成 属性为:  

private int priority://该属性保存一个hroad 实例的优先级,1-10之间的值  

与Thrend 类线程优先级相关的实例方法为:  

方法1:public final int getPriority(),获取线程优先级。  

方法2:public final void setPriority(int priority),设置线程优先级。  

Thread实例的priority.属性默认是5级别,对应的类常量是NORM_PRIORITY。优先级最大 值为10,最小值为1.Thread 类中定义的三个优先级常量如下:4  

public static final int MIN PRIORITY =1; 

public static final int NORM PRIORITY =5; 

public static final int MAX_ PRIORITY-10;+  

Java中使用抢占式调度模型进行线程调度。oriy实例属性的优先级越高,线程获得CPU 时间片的机会越多,但也不是绝对的。举个例子,顺便演示以上两个线程优先级实例方法的使用。  

## 线程的生命周期状态  
 
# 1.4.3线程的生命周期状态  
Java中的线程的生命周期分为6种状态,Tiread 爽有一个实例属性和一个实例方法专门用于 保存和获取线程的状态。其中,用于保存线程Thurcad实例状态的实例属性为:  

private int threadstatus://以垫数的形式保存成位的状态。  

Thread类用于获取线程状态的实例方法为;  

public Thread.state getstate();7/返回当前线程的执行状态,一个收学类型债。  

Thrcal Ste是一个内部枚举类,定义了6个枚举常量,分别代表Jva战程的6种状态,具 体如下:4  

 NEW 新建的

 RUNNABLE 可以执行，包含操作系统的就绪，运行两种状态

 BLOCKED阻塞

 WAITING等待

 TIMED_WAITING计时等待

 TERMINATED终止

 

1. 书上提供了关于线程状态的简单实例,虽然没有进行演示,但线程状态由一个常量定义,存在于 `thread through status`成员中,可通过`data`获取其值｡  

2. 线程状态共有六种:新建､可执行､阻塞､等待､现实等待和终止,每种状态反映了线程在运行过程 中的不同阶段｡  

3. 新建状态表示线程刚刚被创建,但尚未开始执行;可执行状态意味着线程已准备好执行,只需等待处 理器时间｡  

4. 阻塞状态指的是线程由于某种原因暂时无法执行,如等待资源;等待和现实等待状态则分别表示线程 在等待某个条件满足或特定时间到达才能继续执行｡  

5. 终止状态表示线程已完成执行或因异常而停止,不再处于任何可执行状态｡  



## 三种基础状态的转换关系  

<img width="630" height="216" alt="image" src="https://github.com/user-attachments/assets/aa122f6b-43c8-4b1f-9c0a-e210cef9008e" />

新建状态 start() 就绪状态 失去CPU时间片 得到CPU时间片 运行状态 run()结束 异常发生等 终止状态  

State.NEW State.RUNNABLE State.TERMINATED  

图1-11JVM的线程状态及其幕后的操作系统线程状态的转换图(简化版)  
一手资源:vipc9.com 一手微4767893  

1. 线程的三种基本状态:新建(new)､运行(running)､终止(terminated)｡这些状态特指Java 影子线程的状态,其中运行状态表示线程已获取CPU时间片并开始执行指令｡  

2. 内核线程有四种状态:新建､就绪､运行､终止｡就绪状态表示线程等待获取CPU时间片,运行状态 则表示线程正在占用CPU执行指令｡  

3. 除了三种基本状态,线程还可能处于等待(waiting)和阻塞(blocked)状态,这些状态反映了线程在等待某种条件满足或资源可用时的行为｡  

4. Java开发者主要关注的是Java影子线程的状态,即new､running和terminated,而内核线程的更详 细状态(如就绪和运行)由操作系统管理,不在Java层面直接控制｡  

5. 业务指令的执行完毕标志着线程进入terminated状态,无论内核线程处于就绪还是运行状态,Java影 子线程在业务指令执行完毕后都会进入此状态｡  

一手微4767893  

## WAITING&TIMED WAITING的入口条件  

<img width="628" height="157" alt="image" src="https://github.com/user-attachments/assets/a087fc51-1069-4a41-b616-14ff2437e78a" />


状态的操作,大致有以下几种: 线程处于一种特殊的等待状态,准确的说,线程处于限时等待状态,能让线程处于限时等待  
(1) Threadslop Cin);使得当前线程进入限时等待状态。等待时间为n毫秒。"  

(2)Objcrt.wait():带时限的抢占对象的monior。 (3)Threadjoin():带时限的线程合并。  

(4) LockSuppor.parNins();让线程等待。时间以纳秒为单位。"  

(5)LockSupport.parkUntil():让线程等待。时间可以灵活设置。  

一手资源:vipc9.com  
认准一手微4767893  

1. 当调用thread的sleep静态方法时,如果传入了时间参数,当前线程会进入即时等待状态,即time waiting;如果没有传入时间参数,则进入等待状态,即waiting｡  

2. 调用object的wait方法来等待条件,进行条件等待时,线程也会进入等待或即时等待状态｡此方法同 样可以添加时间参数,有时间参数的为time waiting,无时间参数的为waiting｡  

3. 除了sleep和wait方法,thread join等其他方法也可以使线程进入等待状态,具体细节在书中已有详 细介绍｡  

4. 为了更好地理解线程进入waiting状态的过程,可以通过源码工程中的demo,即pass waiting,进行 实践和学习｡  


### 进入WAITING状态的demo  
一手微4767893  
hread-demos  
SafePetStore.java  
93  
94  
95  
96  
97  
98  
99  
100  
101  
102  
103  
104  
java)bcom) crazymakercircle) mutithread  
StatusDemo.java  
ThreadUtil.java  
1 basic)Dcreat  
RandomUtil.java  
Work  
//让线程处于WAITING状态 eTest public void testWaiting()( final Object lock = new Object(); #ynchronized (lock)( try{ lock.wait(); catch(InterruptedException e)(  
一手资源:vipc9.com  
4767893  
手微4767893  

<img width="428" height="302" alt="image" src="https://github.com/user-attachments/assets/9ff3c776-18e7-4994-aaac-b998411a3709" />


### 5.TIMED_WAITING状态  

处于TIMED WAITING(限时等待)状态的线程不会被分配CPU时间片,如果指定时间之 内没有被唤醒,限时等待的线程会被系统自动唤醒,进入就绪状态。以下3个方法会让线程进入 限时等待状态:←  

Thread.sleptine)方法,对应的唤醒方式为:slep睡眠时间结束。  

Object.waiine)方法,对应的唤方式为调用Objc.noifo/ 0bjet.notiAI0主 动唤醒,或者限时结束,  

LockSupport.parkNanos(imeyparkUnti(ie)方法,对应的唤醒方式为:线程调用配套的 LockSupport.upark(Thread)方法结束,或者线程停止(park)时限结束。  

进入BLOCKED状态、WAITING状态、IMEDWAITING状态的线程都会让出CPU的使 用权:另外,等待或者阻塞状态的线程被唤醒后,进入Ready状态,需要重新获取时间片才能接 着运行。  

<img width="648" height="328" alt="image" src="https://github.com/user-attachments/assets/07af0206-88a1-447e-ac3d-e28a77b28803" />


### TIMED WAITING的demo  
```
@Test  
//让线程处于TINED WAITING状态  
pub1ic vod testrimedwaiting (){  
final Object lock=new Object ();  
synchronized (lock){  
try{  
lock.wait(timeout:30*1000);  
catch (InterruptedException e){  
}
```

<img width="604" height="388" alt="image" src="https://github.com/user-attachments/assets/1827c3a0-40aa-407c-8747-68792979b11c" />
  

### 3.BLOCKED状态  

<img width="645" height="330" alt="image" src="https://github.com/user-attachments/assets/10ae4b2e-268e-4d4a-b7ed-d986461a85c6" />


处于阻塞(BLOCKED)状态的线程并不会占用CPU资源,以下情况会让线程进入阻塞状态:  

(1)线程等待获取锁~  

并且线程调度器允许该线程持有该镜时,该线程退出阴塞状态。 等待获取一个锁,而该锁被其他线程持有,则该线程进入阻塞状态、当其他线程释放了该锁,  

(2)10阻塞~  

线程发起了一个阻塞式IO操作后,如果不具备10操作的条件,线程会进入阻塞状态,IO  

包括磁盘10、网络I0等,IO阻塞的一个简单例子:线程等待用户输入内容后继续执行。"  
说 明  
网络10阻塞的原理,以及Java高性能IO编程的核心知识,请参阅另一本书《ava高  
并发核心编程卷1》。  

<img width="636" height="522" alt="image" src="https://github.com/user-attachments/assets/ad78d1ee-6808-40e3-ae47-edc5fee24054" />


1. 线程进入阻塞状态的第一种情况是尝试获取一把由`synchronized`定义的锁,如果这把锁已经被其他 线程持有,当前线程将进入阻塞状态,直到锁被释放｡  

2. 当线程成功抢占到被其他线程持有的锁后,它会退出阻塞状态,继续执行其任务｡  



3. 另一种导致线程进入阻塞状态的情况是进行阻塞式的IO操作,即在IO操作条件不满足时,线程会进入 阻塞状态｡  

4. 在阻塞式IO操作过程中,如果条件仍未满足,线程将持续保持阻塞状态,直到IO操作可以进行或完 成｡  


### B1ock阻塞状态的入口条件  
等待monitor锁(synchronized关键字)的线程,进入BLOCKED状态  
一手微4767893  
//让线程一直处BLOCKEL @Test public void testlocked()( final object lock-new object (); Thread(f public vold run()( #ynohzonizod (lock){ Byatom. out.printin("1got lock,but don't releane"); Threaduti1.sleepi11iSeconds(1000·1000);  
111  
116  
.start O: Threaduti1.sloopMi11iSconds(100*1000); #ynohronized (lock)( Threadtil.aepillion(301000)  
送课+微4767893  

1. 在讨论中提到了一个例子,即一个线程在启动后抢夺锁(lock),而主线程尝试抢占已被匿名线程抢 占的锁,导致主线程被阻塞,进入bug状态｡  

2. 为了解决和观察这种状态,介绍了一种工具叫做JS Baker,通过这个工具可以查看当前JVM的线程信 息,具体指令为`j stack`后跟JVM的进程ID,该进程ID可以通过`GIPS`命令获取｡  

3. 尽管当前不进行实操演示,但强调了在后续的JVM视频中会详细介绍`j stack`指令和JVM线程信息的查 看方法,建议读者在阅读相关书籍后自行尝试｡  

4. 讨论了线程的基本操作,包括线程名称的设置和获取,指出在编程规范中,通过线程池创建线程时指 定有意义的名称非常重要,这可以通过`get name`和设置线程名称来实现｡  

5. 强调了不管是线程处于阻塞状态还是执行状态,都可以通过`j stack`命令查看其状态,这对于理解和 调试多线程程序非常有帮助｡  


导航  
标题  
41.4.后的生命团期状态 1.4的感心况理 1.1的需与时间片 1.4.2丝的优先级  

4.TIMED WIING时等状态  

薹  

41.5.7状态的想结 1.NEW状态  
2  
# 4.WAITING状志  
# 5.TIMEO WATING状态  


1): 1 ..省去不相干的代码 下  

在以上代码中,调用了Thread.currenThread ()静态方法,去获取当前正在执行的线程,简 称为当前线程。准确的说,当前线程就是正在执行当前代码逻辑的Java线程。  
说  
明  
编程规范要求:创建线程或线程池时,需要指定有意义的线程名称,方便出错时回 溯。←  

<img width="772" height="487" alt="image" src="https://github.com/user-attachments/assets/ebfd0de2-60d9-4861-a32c-a1460b00c86c" />


<img width="766" height="490" alt="image" src="https://github.com/user-attachments/assets/025ef722-05ea-45b9-97ae-9c31e84db30c" />


- 1.5.2线程的sleep操作  

sleep的作用是让目前正在执行的线程休眠,让CPU去执行其他的任务。从线程状态来说,从 执行状态变成限时阻塞状态。isleep方法定义在Tiread类中,是一组静态方法,有两个重载版本:4  

//使目前正在执行的线程休眠millis毫秒:4 public static void sleep(long millis) throws InterruptException:  

1. 线程名称的作用是为了在出错时方便进行问题的分析和定位,这是编程规范中的明确要求｡  

2. 需要了解的线程操作包括:睡眠操作sleep､线程的中断､线程的合并､线程的让步,以及守护线程｡  

3. 建议深入学习线程的各种状态,包括new状态､running状态､blocked阻塞状态和waiting状态,理 解它们是如何相互转换的｡  

4. 可以通过阅读相关书籍来深入理解上述概念和操作,以便更好地掌握线程管理的知识｡  

5. 在实际编程中,如果遇到错误,应仔细检查线程的状态和操作,以确定问题的原因并进行相应的调试 和修正｡  


导航  
标题 页面拉学  
1.4.3的生命组状 1.NEW速状态  
2RUNNABLE执行状  
2TERMINATED格止状态  

4.TIMED WATINGR状态  


15.3的ie  


1.NEW状态  

个班4  
4.WAITING状态  
5. TMAED WAITING优态 6.TERMINATED状态  
15安 16.1  

### 6.TERMINATED状态  
线程结束任务之后,将会正常进入TERMINATED (死亡)状态;或者说在线程执行过程中 发生了异常(而没有被处理),也会导致线程进入死亡状态。  

<img width="723" height="409" alt="image" src="https://github.com/user-attachments/assets/62c53ea9-7275-4302-a0ff-fd432911b423" />


## 1.6线程池原理与实战  

Java线程的创建非常昂贵,需要JVM和OS(操作系统)配合完成大量的工作:  

(1)必须为线程堆栈分配和初始化大量内存块,其中包含至少1M的栈内存。  

(2)需要进行系统调用,以便在OS(操作系统)中创建和注册本地线程。  

Java高并发应用频繁创建和销毁线程的操作将是非常低效的,而且是不被编程规范所允许的。 如何降低Java线程的创建成本,就必须使用到线程池。线程池主要解决了以下两个问题:←  
提升性能:线程池能独立负责线程
