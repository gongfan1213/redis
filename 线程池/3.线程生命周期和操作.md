这段内容围绕线程的生命周期、调度模型、基本操作及常见面试题展开，是线程基础知识点的梳理，以下是核心内容概括：


### 一、线程调度模型
线程调度由操作系统完成，Java 线程调度委托给操作系统，主要有两种模型：
1. **分时调度**  
   - 将 CPU 时间划分为时间片，多个线程轮流占用 CPU，平均分配时间片，不断切换执行。  
   - 特点：调度公平但未考虑线程优先级，适用于简单场景。

2. **抢占式调度**  
   - 同样基于时间片，但优先级高的线程会获得更多时间片，优先执行。  
   - Java 线程支持优先级（`priority`），默认值为 5，范围 1-10，优先级越高，获得执行的机会越多。


### 二、线程的生命周期（6种状态及转换）
Java 线程的状态由 `Thread.State` 定义，共 6 种，核心状态及转换如下：
1. **新建（New）**  
   - 线程被创建但未调用 `start()` 方法时的状态。

2. **可运行（Runnable）**  
   - 调用 `start()` 后进入此状态，包含两种情况：  
     - 就绪：等待 CPU 时间片；  
     - 运行：正在占用 CPU 执行。  
   - 此状态下，线程是否执行由操作系统调度决定。

3. **阻塞（Blocked）**  
   - 进入条件：抢占同步锁（`synchronized`）时锁被占用；或执行阻塞式 IO 操作且条件不满足。  
   - 当锁被释放或 IO 操作就绪后，退出阻塞状态。

4. **等待（Waiting）**  
   - 进入条件：调用无超时参数的方法（如 `Object.wait()`、`Thread.join()` 等）。  
   - 需其他线程唤醒（如 `Object.notify()`）才能退出等待。

5. **超时等待（Timed Waiting）**  
   - 进入条件：调用带超时参数的方法（如 `Thread.sleep(long)`、`Object.wait(long)` 等）。  
   - 超时后自动退出等待，或被提前唤醒。

6. **终止（Terminated）**  
   - 线程的 `run()` 方法执行完毕，或因异常终止时的状态。


### 三、线程的基本操作
- **名称管理**：通过 `setName()` 设置、`getName()` 获取线程名称，便于问题定位（编程规范建议设置有意义的名称）。  
- **睡眠**：`Thread.sleep(long)` 使线程进入超时等待状态，暂停执行指定时间。  
- **中断**：通过 `interrupt()` 中断线程，需配合 `isInterrupted()` 判断中断状态。  
- **合并**：`Thread.join()` 让当前线程等待目标线程执行完毕。  
- **让步**：`Thread.yield()` 使当前线程让出 CPU 时间片，进入就绪状态。  
- **守护线程**：通过 `setDaemon(true)` 设置为守护线程，随主线程结束而终止（如垃圾回收线程）。  


### 四、常见面试题：`start()` 与 `run()` 的区别
- **`start()` 方法**：  
  - 作用：启动线程，触发线程进入生命周期（从 New 到 Runnable），由操作系统调度执行。  
  - 特性：异步执行，会启动内核线程，与调用线程并行运行。  

- **`run()` 方法**：  
  - 作用：封装线程的业务逻辑，仅为普通方法。  
  - 特性：直接调用时，由当前线程同步执行（无多线程效果），不会启动新线程。  

- **核心区别**：`start()` 是启动线程的入口，实现异步执行；`run()` 是业务逻辑载体，直接调用仅为同步执行，不启动线程。


### 总结
内容聚焦线程基础，涵盖调度模型、生命周期及核心操作，适合入门学习。`start()` 与 `run()` 的区别是高频考点，需重点理解两者在启动线程和执行逻辑上的本质差异。
