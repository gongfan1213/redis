### 大厂编程规范与线程池的优势
大厂编程规范不允许手动创建线程，主要原因在于性能问题：线程池可统一负责线程的创建、维护、分配与销毁，减少手动创建线程的开销，提升性能；同时线程池能实现线程的动态管理（如按需增减线程），简化线程管理工作。


### JUC线程池框架核心组件
JUC（Java并发包）的线程池框架包含以下核心接口与实现类：
1. **核心接口**  
   - 顶级接口`Executor`：仅含`execute()`方法，用于接收任务。  
   - 子接口`ExecutorService`：扩展了任务接收能力，提供带返回值的`submit()`方法（返回`Future`对象，可用于控制异步任务，如获取结果、取消任务）。  
   - 定时任务接口`ScheduledExecutorService`：支持定时或周期性任务的执行。  

2. **实现类**  
   - 抽象类`AbstractExecutorService`：提供基础实现，为标准线程池提供默认方法。  
   - 核心实现类`ThreadPoolExecutor`：负责线程的创建、销毁、管理及监控，是最常用的线程池实现。  
   - 定时任务实现类`ScheduledThreadPoolExecutor`：实现`ScheduledExecutorService`接口，支持定时/周期性任务。  

3. **快捷工厂类**  
   `Executors`：通过静态方法快捷创建线程池，提供4种常见类型的线程池。


### 向线程池提交任务的方法
线程池提交任务的核心方法及区别如下：
- **`execute(Runnable)`**：无返回值，仅执行任务。  
- **`submit(Runnable)`**：返回`Future`对象，可通过该对象获取任务执行结果或取消任务。  
- **`submit(Callable)`**：支持带返回值的任务，返回`Future`对象，通过`Future.get()`可阻塞获取结果。  

区别：`execute()`仅接收`Runnable`且无返回值；`submit()`支持`Runnable`和`Callable`，且返回`Future`以管理异步任务，同时可在获取结果时处理异常。


### 4种快捷创建线程池的方法（`Executors`工厂类）
1. **单线程线程池（`newSingleThreadExecutor`）**  
   - 特点：池中仅1条线程，任务按提交顺序依次执行；线程不会主动销毁（除非线程池关闭）。  
   - 适用场景：需任务顺序执行的场景。  

2. **固定大小线程池（`newFixedThreadPool`）**  
   - 特点：线程数量固定，可同时执行与线程数相等的任务，超额任务进入队列等待。  
   - 适用场景：CPU密集型任务（减少线程切换开销）。  

3. **可缓存线程池（`newCachedThreadPool`）**  
   - 特点：线程数量动态调整，为每个新任务创建线程（无上限），适合短期突发任务。  
   - 弊端：可能创建大量线程，导致资源耗尽，生产环境不推荐使用。  

4. **可调度线程池（`newScheduledThreadPool`/`newSingleThreadScheduledExecutor`）**  
   - 特点：支持定时或周期性任务（如延迟执行、固定间隔重复执行）。  
   - 适用场景：周期性任务调度（如Spring Boot的任务调度器底层实现）。


### 注意事项
`Executors`工厂类的快捷方法在生产环境不推荐使用，其存在潜在问题（如线程数量无上限、队列容量过大等），具体原因需结合场景分析，后续会有专门内容讲解。实际开发中建议直接使用`ThreadPoolExecutor`自定义线程池以满足需求。


# 本视频主要内容：
为啥大厂的编程规范，不容许显示的手动创建线程


JUC的线程池框架

向线程池提交任务的两种方式

Executors四个快捷创建线程池方法

Executors快捷创建线程池的潜在问题

一手资源：vipc9.com

为啥大厂的编程规范，不容许显示的手动创建线程

    Java高并发应用频繁创建和销毁线程的操作将是非常低效的，而且是不被编程规范所允许的。如何降低Java线程的创建成本，就必须使用到线程池。线程池主要解决了以下两个问题：
 
    (1)提升性能：线程池能独立负责线程的创建、维护、分配。在执行大量异步任务时，可以不需要自己创建线程，而是将任务交给线程池去调度。线程池能尽可能去使用空闲的线程，去执行异步任务，最大限度地对已经创建的线程进行复用，使得性能提升明显。
    
    (2)线程管理：每个Java线程池会保持一些基本的线程统计信息，例如完成的任务数量、空闲时间等，以便对线程进行有效管理，使得能对所接收到异步任务进行高效调度。
说明
    
    在主要大厂的编程规范中，不允许在应用中自行显式创建线程，线程必须通过线程池提供。由于创建和销毁线程上需要时间以及系统资源开销，使用线程池的好处是减少这些开销、解决资源不足的问题。

<img width="407" height="238" alt="image" src="https://github.com/user-attachments/assets/ad40f830-0a91-4050-8240-3e0776cf0c36" />

<img width="508" height="316" alt="image" src="https://github.com/user-attachments/assets/346dbb14-a46b-450d-9944-c407dc86c7c4" />


    1. JUC是Java并发包的缩写，包含两个基本线程池接口，主要用于接收和执行任务，以及一个定时执行周期性任务的接口。
 
    2.存在三个实现类，其中最基本的实现类是Executor，其次是标准实现类，还有一个是可调度的任务性线程池的实现类。
    
3.提到了一个线程池的快捷工厂类，这通常用于方便地创建各种类型的线程池实例。

4.对话中提及的第一个接口是线程池的顶级根接口，仅包含一个executive方法，该方法用于接收任务。
   
    5.这些接口和实现类构成了Java并发编程中处理并发任务和定时任务的核心框架。


# ExecutorService接口

<img width="489" height="155" alt="image" src="https://github.com/user-attachments/assets/99a72f98-ee60-4882-8682-15138fdc62f4" />



# 基础实现勒

<img width="516" height="206" alt="image" src="https://github.com/user-attachments/assets/52d53b96-76fa-408a-a3b1-d88cdbd4acce" />

<img width="623" height="328" alt="image" src="https://github.com/user-attachments/assets/1866fab3-da3e-499c-bcd6-9168e5e6d0ea" />


<img width="552" height="246" alt="image" src="https://github.com/user-attachments/assets/8197633e-22df-45d2-8c32-5aeafdaff72f" />

<img width="587" height="338" alt="image" src="https://github.com/user-attachments/assets/7f3c1a68-ee87-4df7-bbe7-515bd35aed94" />



# submit和execute两类方法区别

<img width="529" height="315" alt="image" src="https://github.com/user-attachments/assets/be994302-18b3-44bd-84b5-00daa816b4b7" />


<img width="582" height="362" alt="image" src="https://github.com/user-attachments/assets/a632d0f9-3b2d-4cea-a854-6594de9ae321" />


<img width="588" height="249" alt="image" src="https://github.com/user-attachments/assets/4945a39f-7e54-4228-8cab-71184e953e50" />


# 固定数量线程池的创建

<img width="565" height="356" alt="image" src="https://github.com/user-attachments/assets/598c1975-1c09-4644-924a-41667cf87127" />


固定数量线程池，处理cpu密集型任务的，在工作线程长时间使用cpu1的情况下，确保可能少的线程分配，减少线程切换和创建销毁操作的开销的

<img width="636" height="206" alt="image" src="https://github.com/user-attachments/assets/beee5663-89d6-4946-9807-8ee90b00bc61" />


# 可缓存的线程池的创建

<img width="562" height="344" alt="image" src="https://github.com/user-attachments/assets/69c58249-77b9-485e-993c-b30b357c0452" />

<img width="604" height="362" alt="image" src="https://github.com/user-attachments/assets/b4e630ea-e46e-47a0-ac67-fcaa987a7cd5" />


<img width="840" height="418" alt="image" src="https://github.com/user-attachments/assets/38bf6a0d-8cdd-468d-bb7f-74869d3a3c7c" />

可缓冲的线程池使用场景是包括需要快速处理大量突发的任务的情况，高并发网络请求，数据批处理任务。

<img width="562" height="243" alt="image" src="https://github.com/user-attachments/assets/7cfb2f22-d8ea-41a6-b257-eda32b5e84d1" />


# 可调度线程池的创建

<img width="586" height="313" alt="image" src="https://github.com/user-attachments/assets/1b15f985-b720-4506-b8ff-6d242bf04cc3" />

<img width="627" height="396" alt="image" src="https://github.com/user-attachments/assets/a027044f-4cd6-4dfb-926b-41e86252efd5" />


<img width="579" height="165" alt="image" src="https://github.com/user-attachments/assets/cd1fb5ff-43fa-4bf3-afe8-c01befeb7340" />


可调度的线程池，周期性的执行任务的场景，springboot的任务调度器，底层借助了juc的scheduleExecutorService的可调度线程池实现，并且可以通过@Configuration配置类型的Bean，可以对调度线程池的实例进行配置，

<img width="579" height="218" alt="image" src="https://github.com/user-attachments/assets/cfca759d-40c7-4c3b-9a9e-57765af98770" />



newFixedThreadPool工厂方法返回一个ThreadPoolExecutor实例，该线程池实例corePoolSize数量为参数nThread,其中maximunPoolsize数量也是参数nThread,其中workQueue属性的值为LinkedBlockingQueue<Runnable>()无解阻塞队列，


使用execuors创建的固定数量的线程池的潜在问题主要存在于workqueue上的，其中值为LinkedBLockingQueue无解阻塞队列，如果任务提交速度持续大雨任务的处理速度，就会造成队列当中大量的任务的等待的，如果队列很大，很有可能会导致jvm出现oom的异常，甚至造成内存资源的耗尽



