### 标准线程池（`ThreadPoolExecutor`）的核心知识

#### 一、大厂规范：禁用快捷线程池，使用标准线程池
大厂编程规范要求通过 `ThreadPoolExecutor` 构造线程池，而非 `Executors` 的快捷方法，原因是快捷方法存在潜在性能问题（如无界队列导致内存溢出）。标准线程池可通过自定义参数精准控制资源，符合高并发场景的稳定性需求。


#### 二、`ThreadPoolExecutor` 的六大核心参数
构造标准线程池需指定以下参数，直接影响线程池的行为逻辑：
1. **核心线程数（`corePoolSize`）**  
   线程池长期保留的线程数量，即使空闲也不会被回收（默认情况下）。若任务数超过核心线程数，多余任务会进入工作队列。

2. **最大线程数（`maximumPoolSize`）**  
   线程池允许创建的最大线程数（核心线程 + 非核心线程）。当工作队列满时，会创建非核心线程处理任务，直至达到该上限。

3. **空闲线程存活时间（`keepAliveTime`）**  
   非核心线程的空闲超时时间，超过此时长则被回收。若通过 `allowCoreThreadTimeOut(true)` 配置，核心线程也会遵守该超时规则。

4. **工作队列（`workQueue`）**  
   用于存放待执行任务的阻塞队列（如 `LinkedBlockingQueue`、`ArrayBlockingQueue`）。当核心线程满时，新任务会先进入队列等待。

5. **线程工厂（`threadFactory`）**  
   用于创建线程的工厂，可自定义线程名称、优先级等属性。编程规范要求线程名称需有意义，便于问题定位。

6. **拒绝策略（`RejectedExecutionHandler`）**  
   当线程池（线程满 + 队列满）或已关闭时，新任务的处理策略。常见策略包括：  
   - 抛出异常（默认）、静默丢弃、替换最旧任务、由提交任务的线程自行执行，或自定义策略。


#### 三、线程池提交任务的流程
向线程池提交任务时，遵循以下逻辑（结合核心参数）：
1. 若当前线程数 < 核心线程数，直接创建核心线程执行任务；  
2. 若核心线程满，将任务放入工作队列等待；  
3. 若队列满且当前线程数 < 最大线程数，创建非核心线程执行任务；  
4. 若队列满且线程数已达最大值，触发拒绝策略。


#### 四、工作线程的主循环逻辑
线程池中的工作线程（`Worker`）执行任务的流程：
1. 新创建的线程首先执行初始化时的“首任务”；  
2. 任务完成后，从工作队列中循环获取下一个任务（阻塞队列会阻塞等待新任务）；  
3. 若长期无任务（超过存活时间），且当前线程数 > 核心线程数，则该线程被回收。


#### 五、线程池的钩子方法
`ThreadPoolExecutor` 提供两个钩子方法，可通过子类重写实现定制化逻辑：
- `beforeExecute(Thread t, Runnable r)`：任务执行前调用（如记录开始时间）；  
- `afterExecute(Runnable r, Throwable t)`：任务执行后调用（如计算执行耗时、记录日志）。  
需注意在钩子方法中清理线程本地变量，避免数据混乱。


#### 总结
标准线程池通过六大参数实现精细化资源控制，是大厂规范推荐的线程管理方式。理解其任务提交流程、工作线程循环及钩子方法，有助于优化线程池性能并排查问题。建议结合实际场景调整参数（如核心线程数、队列类型），避免资源耗尽风险。


# 标准线程池的创建与原理

<img width="486" height="352" alt="image" src="https://github.com/user-attachments/assets/e1c752a0-ea2e-45bc-9684-160259154f3c" />


一手微4767893  
一手资源:vipc9.com  
送课+微4767893  

## 线程池核心组件
- Blocking Queue<Runnable> workQueue（工作队列）
- 核心线程（corePool）
- 最大线程（maximumPool）
- 线程（worker）
- RejectedExecutionHandler（拒绝策略）
- 主线程的execute()方法

## 核心参数说明
### 参1/2: 核心和最大线程数量
- 参数`corePoolSize`用于设置核心（Core）线程池数量，参数`maximumPoolSize`用于设置最大线程数量。线程池执行器将会根据`corePoolSize`和`maximumPoolSize`自动地维护线程池中的工作线程，大致的规则为：
  1. 当在线程池接收到的新任务，并且当前工作线程数少于`corePoolSize`时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求，直到线程数达到`corePoolSize`。
  2. 如果当前工作线程数多于`corePoolSize`数量，但小于`maximumPoolSize`数量，则仅当任务排队队列已满时，才会创建新线程。通过设置`corePoolSize`和`maximumPoolSize`相同，可以创建一个固定大小的线程池。
  3. 当`maximumPoolSize`被设置为无界值（如`Integer.MAX_VALUE`）时，线程池可以接收任意数量的并发任务。
  4. `corePoolSize`和`maximumPoolSize`不仅能在线程池构造时设置，也可以使用`setCorePoolSize`和`setMaximumPoolSize`两个方法进行动态更改。

### 参3: keepAliveTime
- 线程构造器的`keepAliveTime`（空闲线程存活时间）参数，用于设置池内线程最大Idle（空闲）时长或者说保活时长，如果超过这个时间，默认情况下Idle、非Core线程会被回收。
- 如果池在使用过程中，提交任务的频率变高，也可以使用方法`setKeepAliveTime(long, TimeUnit)`进行线程存活时间的动态调整，可以时长延长。如果需要防止Idle（空闲）线程被终止，可以将Idle（空闲）时间设置为无限大，具体如下：`setKeepAliveTime(Long.MAX_VALUE, TimeUnit.NANOSECONDS);`
- 默认情况下，Idle超时策略仅适用于存在超过`corePoolSize`线程的情况。但是如果调用了`allowCoreThreadTimeOut(boolean)`方法，并且传入了参数`true`，则`keepAliveTime`参数所设置的Idle超时策略也将被应用于核心线程。

### 参5: ThreadFactory线程工厂
- `ThreadFactory`是Java线程工厂接口，这是一个非常简单的接口，具体如下：
  ```java
  package java.util.concurrent;
  public interface ThreadFactory {
      // 唯一的方法：创建一条新线程
      Thread newThread(Runnable target);
  }
  ```
- 在使用`ThreadFactory`的唯一方法`newThread()`创建新线程时，可以更改所创建新线程的名称、线程组、优先级、守护进程状态等。如果`newThread()`返回值为`null`，表示线程工厂未能成功创建线程，则线程池可能无法执行任何任务。

<img width="486" height="352" alt="image" src="https://github.com/user-attachments/assets/ab5152c8-fdec-46fd-9626-9cb6185ebf74" />


### 拒绝策略
#### 自定义拒绝策略
```java
public static class CustomIgnorePolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, @NotNull ThreadPoolExecutor e) {
        // 可做日志记录等
        Print.tco(r + "rejected;" + "-getTaskCount:" + e.getTaskCount());
    }
}
// 拒绝和异常策略
RejectedExecutionHandler policy = new CustomIgnorePolicy();
ThreadPoolExecutor pool = new ThreadPoolExecutor(
    corePoolSize,
    maximumPoolsize,
    keepAliveTime, unit,
    workQueue,
    threadFactory,
    policy
);
```

## execute(Runnable command)方法的源码
```java
int c = ctl.get();
// 工作线程数量小于核心线程数量 新建工作线程
if (workerCountOf(c) < corePoolSize) {
    if (addWorker(command, true))
        return;
    c = ctl.get();
}
// 如果工作线程大于核心线程数，则把任务添加到阻塞队列中
if (isRunning(c) && workQueue.offer(command)) {
    int recheck = ctl.get();
    if (!isRunning(recheck) && remove(command))
        reject(command);
    else if (workerCountOf(recheck) == 0)
        addWorker(null, false);
}
// 如果阻塞队列满了，创建新线程
// 如果创建失败，说明线程数达到最大线程数，则执行拒绝策略
else if (!addWorker(command, false))
    reject(command);
```

## ThreadPoolExecutor.execute(Runnable)流程
1. 判断当前线程数是否小于`corePoolSize`：
   - 是：新建线程，并在线程中执行任务
   - 否：进入下一步
2. 判断队列是否已满：
   - 否：任务加入队列
   - 是：进入下一步
3. 判断当前线程数是否小于`maximumPoolSize`：
   - 是：新建线程，并在线程中执行任务
   - 否：执行拒绝策略（handler）
4. 线程执行任务后，尝试从队列获取任务：
   - 获取到任务：继续执行任务
   - 未获取到任务：
     - 判断当前线程数是否大于`corePoolSize`：
       - 是：关闭当前线程，当前线程数减1
       - 否：继续等待获取任务

一手资源:vipc9.com  
回收正版课+4767893

<img width="598" height="373" alt="image" src="https://github.com/user-attachments/assets/d68be019-c4b6-4846-a930-c338257e4f3d" />
