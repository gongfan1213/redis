### 线程池核心线程数配置策略（以IO密集型任务为例）

#### 一、任务类型与线程数配置的关联
线程池的核心线程数配置需根据任务类型确定，主要分为三类：
- **IO密集型任务**：大部分时间用于IO操作（如网络请求、数据库交互），CPU利用率低。
- **CPU密集型任务**：主要占用CPU进行计算，CPU利用率高。
- **混合型任务**：兼具IO操作和CPU计算（如Web服务器请求处理）。

本节重点讲解**IO密集型任务**的线程数配置。


#### 二、IO密集型任务的线程数配置原理
1. **特点分析**  
   IO密集型任务的核心耗时在于IO操作（如网络传输、磁盘读写），而CPU仅负责内存数据复制（非直接操作硬件），因此CPU空闲时间较多。此时适当增加线程数可提高CPU利用率，但并非越多越好（线程切换会带来额外开销）。

2. **配置公式**  
   核心线程数通常设置为 **CPU核心数的2倍**，例如：  
   - 4核CPU → 8个核心线程  
   - 8核CPU → 16个核心线程  

   这一规则被广泛采用（如Netty的IO线程默认配置为`CPU核心数×2`），平衡了CPU利用率和线程切换成本。


#### 三、IO密集型线程池的创建要点
以随书源码中的实现为例，关键配置如下：

1. **核心参数设置**  
   - **核心线程数（corePoolSize）** = 最大线程数（maximumPoolSize）= `CPU核心数×2`  
     目的：优先创建线程处理任务，而非将任务放入队列等待，减少延迟。  
   - **工作队列**：使用**有界阻塞队列**（如`LinkedBlockingQueue`并指定容量），避免无界队列导致的内存溢出（OOM）。  
   - **空闲线程存活时间**：通过`allowCoreThreadTimeOut(true)`允许核心线程超时销毁，避免无任务时的资源浪费。  

2. **线程池模式**  
   采用**懒汉单例模式（静态内部类实现）**，确保：  
   - 线程安全：类加载机制保证单例实例的线程安全初始化。  
   - 延迟加载：仅在首次使用时创建线程池，减少启动资源消耗。  

3. **自动关闭机制**  
   注册JVM关闭钩子（`ShutdownHook`），确保JVM退出时线程池优雅关闭，释放资源。


#### 四、示例代码（IO密集型线程池）
```java
public class IOIntensiveThreadPool {
    // 静态内部类实现懒汉单例
    private static class LazyHolder {
        // 获取CPU核心数
        private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
        // 核心线程数 = CPU核心数 × 2
        private static final int CORE_POOL_SIZE = CPU_COUNT * 2;
        // 最大线程数与核心线程数一致
        private static final int MAX_POOL_SIZE = CORE_POOL_SIZE;
        // 有界队列容量
        private static final int QUEUE_CAPACITY = 1024;
        // 空闲线程存活时间（秒）
        private static final long KEEP_ALIVE_TIME = 60;

        // 初始化线程池
        private static final ThreadPoolExecutor INSTANCE = new ThreadPoolExecutor(
            CORE_POOL_SIZE,
            MAX_POOL_SIZE,
            KEEP_ALIVE_TIME,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(QUEUE_CAPACITY),
            new CustomThreadFactory("io-intensive-pool"), // 自定义线程工厂（指定名称）
            new CustomRejectedHandler() // 自定义拒绝策略
        );

        static {
            // 允许核心线程超时销毁
            INSTANCE.allowCoreThreadTimeOut(true);
            // 注册JVM关闭钩子，优雅关闭线程池
            Runtime.getRuntime().addShutdownHook(new Thread(INSTANCE::shutdown));
        }
    }

    // 获取单例实例
    public static ThreadPoolExecutor getInstance() {
        return LazyHolder.INSTANCE;
    }

    // 私有构造器防止实例化
    private IOIntensiveThreadPool() {}
}
```


#### 五、关键设计说明
1. **线程工厂与拒绝策略**  
   - 自定义线程工厂可设置线程名称（如`io-intensive-pool-1`），便于问题排查。  
   - 拒绝策略可根据业务需求实现（如日志记录、任务缓存），避免任务丢失。  

2. **为什么核心线程数=最大线程数？**  
   确保任务优先被新线程处理，而非进入队列等待，减少IO密集型任务的响应延迟。  

3. **与书籍/视频的配合**  
   基础理论（如零复制、线程池原理）详见《Java高并发核心编程》，视频补充实战配置与源码解析，形成互补。


#### 总结
IO密集型线程池的核心是**合理利用CPU空闲时间**，通过`CPU核心数×2`的线程数配置平衡效率与
开销，同时结合有界队列、懒加载和自动关闭机制，确保高并发场景下的稳定性。

# IO密集型线程池的线程数配置
一手微4767893  
送课+微4767893  


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/ab1b4ca0-4fcd-477e-993c-c845887835db" />


## 按照任务类型对线程池进行分类
使用标准构造器 `ThreadPoolExecutor` 去创建线程池时，会涉及到线程数的配置，而线程数的配置与异步任务类型是分不开的。这里将线程池的异步任务大致分为以下三类：  
1. **IO密集型任务**  
   此类任务主要是执行 IO 操作。由于执行 IO 操作的时间较长，导致 CPU 的利用率不高，这类任务 CPU 常处于空闲状态。Netty 的 IO 读写操作，为此类任务的典型例子。  
2. **CPU密集型任务**  
   此类任务主要是执行计算任务。由于响应时间很快，CPU 一直在运行，这种任务 CPU 的利用率很高。  
3. **混合型任务**  
   此类任务既要执行逻辑计算，又要进行 IO 操作（如 RPC 调用、数据库访问）。相对来说由于执行 IO 操作的耗时较长（一次网络往返往往在数百毫秒级别），这类任务 CPU 利用率也不是太高。Web 服务器的 HTTP 请求处理操作，为此类任务的典型例子。  

一般情况下，针对以上不同类型的异步任务，需要创建不同类型的线程池，并进行针对性的参数配置。  

## IO密集型任务的特点
此类任务主要是执行 IO 操作。由于执行 IO 操作的时间较长，导致 CPU 的利用率不高，这类任务 CPU 常处于空闲状态。Netty 的 IO 读写操作，为此类任务的典型例子。  


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/c9d5569c-5532-4c21-a28a-aa1595b7ae0a" />

1. CPU不再直接与设备进行IO操作，而是通过内存复制来完成，例如将用户缓冲区的数据复制到内核socket缓冲区。


2. 真正的效率瓶颈在于设备操作，而非内存操作，因为内存操作速度相对较快。


3. IO密集型任务的线程数通常不会超过CPU核数的2倍，因为其性能瓶颈并不在于CPU处理速度。

4. 明确理解“零复制”概念，尤其是在Java中，这是对基础知识最准确和深入的解读，对于优化IO操作至关重要。


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/dbe9462a-1083-41a1-9a95-1d83a2c5a4f2" />

1. Netty的反应器模型中，一个组包含的反应器实际上就是我们的IO线程，其线程数默认为CPU核数的2倍。

2. 强调掌握Netty及反应器模型等高级知识的重要性，这是提升编程效率和理解的关键。

3. 推荐了一本由作者撰写的书，原名《native zoo e redy高频化实战》，后更名为《java高并发核心编程》，该书被广泛认为是易懂且深入的资源。

4. 作者建议读者观看其配套视频，视频内容与书中的基础性知识相互补充，以加深理解和实践能力。

5. 强调了学习和掌握这些知识的重要性，尤其是对于希望在编程领域提升自我的读者而言。

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/6f3fac1e-2402-41e2-81bb-976254851ae1" />

## 零复制相关内容
### 内存零复制原理（mmap + write 模式）
- 用户进程通过 `write()` 调用，将用户缓冲区（用户空间，堆外内存区域）的数据通过 **CPU 复制** 到内核缓冲区（内核空间）。  
- 内核缓冲区数据通过 **DMA 复制** 到 Socket 缓冲区，最终通过 **DMA 复制** 到底层硬件（磁盘/网卡）。  

### 相关学习内容
- NioEventLoop（反应器）核心原理  
- NioEventLoop 任务队列核心原理  
- ChannelConfig 通道配置类  
- 彻底明白：内核态、用户态、内核空间、用户空间  
- 彻底明白：Java 的零复制（史上最准确、最强悍解读）  
- 彻底明白：Netty 的零复制（史上最准确、最强悍解读）  

## IO密集型任务线程池参考代码
```java
private static class IoIntenseTargetThreadPoolLazyHolder {
    // 线程池：用于 IO 密集型任务
    private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor(
        IO_MAX, // CPU 核数 * 2
        IO_MAX, // CPU 核数 * 2
        KEEP_ALIVE_SECONDS,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue(QUEUE_SIZE),
        new CustomThreadFactory("io")
    );
}
```

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/27a8ceb5-622e-43d8-9681-9279187d9790" />


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/403ae1a1-6fbc-4afa-90cf-58943681e382" />

1. 允许核心线程在超时闲置时被销毁，即调用`allowCoreThreadTimeOut(true)`，确保在无IO任务时，核心线程不会持续占用资源。



2. 设置此参数为true的好处是，当系统长时间无任务执行时，可以关闭空闲的核心线程，节省资源；待有新任务时，再重新启动这些线程。

3. 默认情况下，如果不进行上述设置，两倍于CPU数量的核心线程将始终处于活跃状态，即使在无任务执行时，也会造成资源浪费。

4. 使用有界工作队列作为线程池的参数之一，这意味着队列具有固定大小，可以限制等待执行的任务数量，防止资源过度消耗。

5. 通过调整线程池的构造器参数，可以有效管理线程的生命周期和资源使用，确保在低负载情况下系统资源的高效利用。



## 配置要点
1. **允许核心线程销毁**  

   调用 `allowCoreThreadTimeOut(true)` 方法，使核心线程也遵循空闲超时策略，长时间空闲时自动销毁，避免资源浪费。  
   ```java
   EXECUTOR.allowCoreThreadTimeOut(true);
   ```


<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/a94cc6e9-e8b0-42aa-b057-1030d4189e86" />


2. **使用有界队列**  

   采用有界阻塞队列（如 `LinkedBlockingQueue` 并指定容量），避免无界队列导致的内存溢出（OOM）。  
   ```java
   private static final int QUEUE_SIZE = 128; // 可根据需求调整
   new LinkedBlockingQueue(QUEUE_SIZE)
   ```  

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/498bd17c-c32b-481d-8dae-98ef57774a57" />

1. 在处理任务时，优先创建线程而非将任务加入阻塞队列，即在核心线程未满时，优先创建新线程。

2. 通过将核心线程数和最大线程数设置为一致，实现任务优先加入阻塞队列的条件，即线程数达到上限时才将任务加入队列。

3. 当线程需要使用时才创建，而非在启动时创建，这利用了懒汉单例模式。

4. 懒汉单例模式的实现采用静态内部类的方式，确保线程在需要时才被创建，提高效率和资源利用率。


3. **优先创建线程，而非加入队列**  
   核心线程数（`corePoolSize`）与最大线程数（`maximumPoolSize`）保持一致，确保新任务优先由新线程处理，减少等待延迟。  

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/b58e7c7d-fa07-41d5-b475-2cbf70905f4c" />


4. **JVM 关闭时自动关闭线程池**  
   注册 JVM 关闭钩子，在 JVM 退出时优雅关闭线程池，释放资源：  
   ```java
   Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(
       "IO 密集型任务线程池",
       new Callable<Void>() {
           @Override
           public Void call() throws Exception {
               shutdownThreadPoolGracefully(EXECUTOR);
               return null;
           }
       }
   ));
   ```  

## 源码与示例
- **源码工程**：https://gitee.com/crazymaker/Java-high-concurrency-core-Programming-Volume-2-source-code.git  
- **案例**：`testIoIntenseTargetThreadPool`  

### 示例输出
```
[ThreadPoolDemo$1.run]: apppool-1-io-2, 轮次:1
[ThreadPoolDemo$1.run]: apppool-1-io-2, 轮次:2
[ThreadPoolDemo$1.run]: apppool-1-io-2, 轮次:3
[ThreadPoolDemo$1.run]: apppool-1-io-2, 轮次:4
[ThreadPoolDemo$1.run]: apppool-1-io-2 运行结束.
[ThreadPoolDemo$1.run]: apppool-1-io-1, 轮次:1
[ThreadPoolDemo$1.run]: apppool-1-io-1, 轮次:2
[ThreadPoolDemo$1.run]: apppool-1-io-1, 轮次:3
[ThreadPoolDemo$1.run]: apppool-1-io-1, 轮次:4
[ThreadPoolDemo$1.run]: apppool-1-io-1 运行结束.
```

一手资源:vipc9.com  
回收正版课+4767893
