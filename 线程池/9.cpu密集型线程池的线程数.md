### CPU密集型线程池的配置与实现

#### 一、CPU密集型任务的特点
CPU密集型任务以大量计算为核心（如圆周率计算、视频编解码等），其特点是：
- 主要占用CPU资源，CPU利用率极高；
- 任务执行过程中几乎无IO操作，无需等待外部资源；
- 线程切换会显著降低效率，因此需尽量减少线程数量，避免频繁切换。


#### 二、CPU密集型线程池的核心参数配置
与IO密集型线程池相比，CPU密集型线程池的核心差异在于**线程数配置**，其他参数设计思路基本一致：

1. **核心线程数与最大线程数**  
   线程数直接等于**CPU核心数**（通过`Runtime.getRuntime().availableProcessors()`获取），无需额外倍数。  
   原因：CPU密集型任务依赖CPU计算，线程数超过核心数会导致频繁切换，反而降低效率。

2. **其他关键参数**  
   - **有界阻塞队列**：使用`LinkedBlockingQueue`并指定容量（如128），避免无界队列导致的OOM。  
   - **核心线程超时销毁**：通过`allowCoreThreadTimeOut(true)`允许核心线程空闲超时后销毁，减少资源浪费。  
   - **线程工厂**：自定义线程工厂，为线程命名（如`cpu-intensive-pool-1`），便于问题排查。  
   - **JVM关闭钩子**：注册钩子函数，确保JVM退出时线程池优雅关闭（调用`shutdown()`）。


#### 三、参考代码实现
```java
public class CpuIntensiveThreadPool {
    // 静态内部类实现懒汉单例（线程安全）
    private static class LazyHolder {
        // 获取CPU核心数
        private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
        // 有界队列容量
        private static final int QUEUE_SIZE = 128;
        // 空闲线程存活时间（秒）
        private static final long KEEP_ALIVE_SECONDS = 60;

        // 初始化CPU密集型线程池
        private static final ThreadPoolExecutor INSTANCE = new ThreadPoolExecutor(
            CPU_COUNT, // 核心线程数 = CPU核心数
            CPU_COUNT, // 最大线程数 = CPU核心数
            KEEP_ALIVE_SECONDS,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(QUEUE_SIZE),
            new CustomThreadFactory("cpu-intensive-pool"), // 自定义线程工厂
            new CustomRejectedHandler() // 自定义拒绝策略
        );

        static {
            // 允许核心线程超时销毁
            INSTANCE.allowCoreThreadTimeOut(true);
            // 注册JVM关闭钩子，优雅关闭线程池
            Runtime.getRuntime().addShutdownHook(new Thread(INSTANCE::shutdown));
        }
    }

    // 获取单例实例
    public static ThreadPoolExecutor getInstance() {
        return LazyHolder.INSTANCE;
    }

    // 私有构造器防止实例化
    private CpuIntensiveThreadPool() {}
}
```


#### 四、使用示例
```java
public class ThreadPoolDemo {
    public static void testCpuIntensiveThreadPool() {
        // 获取CPU密集型线程池实例
        ThreadPoolExecutor pool = CpuIntensiveThreadPool.getInstance();

        // 提交任务
        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            pool.submit(() -> {
                // 模拟CPU密集型任务（如计算）
                long result = 0;
                for (long j = 0; j < 10_000_000L; j++) {
                    result += j;
                }
                System.out.println("任务" + taskId + "执行完成，结果：" + result);
            });
        }
    }

    public static void main(String[] args) {
        testCpuIntensiveThreadPool();
    }
}
```


#### 五、设计要点总结
1. **线程数控制**：核心线程数 = 最大线程数 = CPU核心数，避免线程切换损耗。  
2. **资源保护**：有界队列+自定义拒绝策略，防止任务积压导致内存溢出。  
3. **懒加载与线程安全**：静态内部类实现懒汉单例，确保高并发下的实例唯一性。  
4. **自动销毁机制**：核心线程超时销毁+JVM关闭钩子，减少闲置资源占用。

CPU密集型线程池的设计核心是**“减少线程切换，最大化CPU利用率”**，通过精准控制线程数与资源边
界，确保计算任务高效执行。


# CPU密集型线程池的线程数配置
一手微4767893  
送课+微4767893  

## CPU密集型任务的特点
CPU密集型任务虽然也可以并行完成，但是并行的任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。  
所以，要最高效地利用CPU，CPU密集型任务的并行执行的数量应当等于CPU的核心数。  

## CPU密集型任务线程池参考代码
```java
// 线程池：用于CPU密集型任务
private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor(
    MAXIMUM_POOL_SIZE,
    MAXIMUM_POOL_SIZE,
    KEEP_ALIVE_SECONDS,
    TimeUnit.SECONDS,
    new LinkedBlockingQueue(QUEUE_SIZE),
    new CustomThreadFactory("cpu")
);
```

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/8a30bf71-f3e7-42e8-8218-4f78dcae01bf" />

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/dc996076-533c-4360-9927-deb0ec2ca24d" />


## 测试用例代码
```java
@Test
public void testCpuIntenseTargetThreadPool() {
    ThreadPoolExecutor pool = ThreadUtil.getCpuIntenseTargetThreadPool();
    for (int i = 0; i < 2; i++) {
        pool.submit(new Runnable() {
            @Override
            public void run() {
                for (int j = 1; j < MAX_TURN; j++) {
                    Print.cfo(getCurThreadName() + ", 轮次:" + j);
                }
                Print.cfo(getCurThreadName() + "运行结束.");
            }
        });
    }
    ThreadUtil.sleepMilliseconds(Integer.MAX_VALUE);
}
```

## 测试输出示例
```
[ThreadPoolDemo$2.run]: apppool-1-cpu-1, 轮次:3
[ThreadPoolDemo$2.run]: apppool-1-cpu-1, 轮次:4
[ThreadPoolDemo$2.run]: apppool-1-cpu-1 运行结束.
```

3. 线程工厂被定制，用于生成具有特定命名规则的线程，这有助于在多线程环境中更好地追踪和管理线程。

4. 在静态初始化块中，配置核心线程在长时间空闲后可以被关闭，这有助于节省资源并提高效率。

5. 通过在JVM上添加钩子方法，实现了程序退出时自动调用线程池的优雅关闭方法（shutdown），确保了CPU密集型任务实验室能够被妥善关闭，避免资源泄露。



<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/2c017882-76a7-4539-a81b-79be6564be12" />

<img width="1892" height="902" alt="image" src="https://github.com/user-attachments/assets/015abab5-63f7-4f34-81ff-bd07c15c8abc" />


一手资源:vipc9.com  
送课+微4767893
